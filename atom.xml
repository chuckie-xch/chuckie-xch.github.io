<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>夏天的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.idlforever.cn/"/>
  <updated>2018-04-14T09:24:29.525Z</updated>
  <id>http://www.idlforever.cn/</id>
  
  <author>
    <name>chuckie-xch</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker入门</title>
    <link href="http://www.idlforever.cn/2018/04/13/Docker%E5%85%A5%E9%97%A8/"/>
    <id>http://www.idlforever.cn/2018/04/13/Docker入门/</id>
    <published>2018-04-13T18:22:35.000Z</published>
    <updated>2018-04-14T09:24:29.525Z</updated>
    
    <content type="html"><![CDATA[<p>查看有哪些镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p>获取镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull ubuntu:16.04</span><br></pre></td></tr></table></figure><a id="more"></a><p>等待下载完成，获取一个官方的<code>ubuntu 16.04</code>的官方镜像。</p><p>然后，使用docker run命令可以从一个镜像运行一个包含一个主进程的容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -ti --name first ubuntu:16.04 bash</span><br></pre></td></tr></table></figure><blockquote><p>命令解释：</p><ul><li>docker run ：从一个镜像运行一个容器。</li><li>-ti（terminal interactive）：进入容器的交互式终端。</li><li>–name：指定容器的名字，后面的first就是容器的命名。</li><li>ubuntu:16.04：指明从哪个镜像运行容器，ubuntu指仓库名，16.04是标签。</li><li>bash：指明使用bash终端。</li></ul></blockquote><p>现在，可以在容器里执行一些命令，就好像在一个全新的系统中运行指令一样，比如创建文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch hello-docker.txt</span><br></pre></td></tr></table></figure><p>现在，可以通过输入exit命令退出运行的容器，其实就是终止了容器。</p><p>如果将来，你希望每次运行一个新容器都包含刚刚创建的hello-docker.txt，可以把容器提交为一个镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit first my-image:v1.0</span><br></pre></td></tr></table></figure><p>注意：这种创建镜像的方式并不推荐，应该避免通过这种方式创建镜像。</p><p>后台运行：docker run -d …</p><p>删除容器：docker rm …</p><h4 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h4><ul><li>ssh登录</li><li>attach和exec</li><li>nesenter</li></ul><p>在后台运行一个新的容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -ti --name background ubuntu:16.04 bash</span><br></pre></td></tr></table></figure><p>使用如下命令进入容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec  -ti backgroud bash</span><br></pre></td></tr></table></figure><p>第二种方式是使用attach命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker attach background</span><br></pre></td></tr></table></figure><p>然后按两次回车即可进入容器。</p><h4 id="终止容器"><a href="#终止容器" class="headerlink" title="终止容器"></a>终止容器</h4><ul><li>进入容器，然后输入命令：<code>exit</code></li><li>通过kill命令</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker kill background</span><br></pre></td></tr></table></figure><h4 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><h4 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h4><ul><li><p>查看容器详细信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect background</span><br></pre></td></tr></table></figure></li><li><p>查看容器最近一个进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top background</span><br></pre></td></tr></table></figure></li><li><p>停止一个正在运行的容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop background</span><br></pre></td></tr></table></figure></li><li><p>继续一个被停止的容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart background</span><br></pre></td></tr></table></figure></li><li><p>暂停一个一个容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pause background</span><br></pre></td></tr></table></figure></li><li><p>取消暂停</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker unpause background</span><br></pre></td></tr></table></figure></li><li><p>终止一个容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker kill background</span><br></pre></td></tr></table></figure><p>​</p></li></ul><h4 id="Docker数据管理的方式"><a href="#Docker数据管理的方式" class="headerlink" title="Docker数据管理的方式"></a>Docker数据管理的方式</h4><h5 id="数据卷（Data-Volume）"><a href="#数据卷（Data-Volume）" class="headerlink" title="数据卷（Data Volume）"></a>数据卷（Data Volume）</h5><p>数据卷的使用其实和Linux挂载文件目录是很相似的，数据卷就是一个可以供容器使用的特殊目录。</p><ul><li><strong>创建一个数据卷</strong></li></ul><p>在使用<code>docker run</code>命令的时候使用-v参数为容器挂载一个数据卷：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -ti --name hasVolume -v /myDir ubuntu:16.04 bash</span><br></pre></td></tr></table></figure><p>然后可以看到我们的容器的目录里多了一个myDir的目录，这个就是数据卷：</p><p><a href="https://i.loli.net/2018/04/14/5ad19e97dbef4.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/04/14/5ad19e97dbef4.png" alt="volume-1.png"></a></p><ul><li><strong>删除一个数据卷</strong></li></ul><p>数据卷的生命周期是独立于容器的，所以要删除数据卷，必须在删除容器的时候加上-v参数，</p><p>注意：如果你删除了挂载某个数据卷的全部容器，而没有使用-v清理数据卷，之后再想清除这个数据卷将会非常麻烦，所以，尽量在删除最后一个挂载该数据卷的容器时加上-v参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -v hasVolume</span><br></pre></td></tr></table></figure><ul><li><strong>挂载一个主机目录到数据卷</strong></li></ul><p>使用如下命令挂载一个主机目录到数据卷：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -ti --name volume1 -v /home/xch/:/myShared ubuntu:16.04 bash</span><br></pre></td></tr></table></figure><p>意思是，将宿主机上的/home/xch挂载到容器的myShared目录下，Docker挂载目录的默认权限是读写，可以通过<code>:ro</code>命令设置为只读：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -ti --name volume2 -v /home/xch/:/myShared:ro ubuntu:16.04 bash</span><br></pre></td></tr></table></figure><h5 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h5><p>数据卷容器就是一个普通的容器，只不过这个容器是专门作为数据卷供其他容器挂载。</p><p>首先，运行容器时创建一个数据卷容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -ti --name v0 -d -v /data-volume ubuntu:16.04</span><br></pre></td></tr></table></figure><p>接着，创建一个新的容器挂载刚才创建的数据卷容器中的数据卷，使用–volumes-from参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -ti --name v1 --volumes-from v0 ubuntu:16.04 bash</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><ul><li>数据卷容器被挂载时不必保证运行</li><li>如果删除了v0，v1数据卷并不会被清理，应当运行docker rm -v命令</li></ul></blockquote><h3 id="Docker网络"><a href="#Docker网络" class="headerlink" title="Docker网络"></a>Docker网络</h3><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>由于ubuntu的官方镜像并没有默认安装ping，ifconfig等网络工具，所以需要创建一个具备一定网络功能的镜像（目前先使用容器提交的方式，后续再介绍dockerfile创建镜像）。</p><p>首先，从之前的的ubuntu:16.04创建一个容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -ti --name network-example ubuntu:16.04 bash</span><br></pre></td></tr></table></figure><p>然后依次执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install vim</span><br><span class="line">apt-get install net-tools</span><br><span class="line">apt install iputils-ping</span><br><span class="line">apt install apache2</span><br><span class="line">apt install apache2-utils</span><br><span class="line">apt install openssh-server</span><br><span class="line">apt install openssh-client</span><br></pre></td></tr></table></figure><p>接着，使用vim修改：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><p>将<code>PermitRootLogin</code>内容改为yes，保存退出。</p><p>输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd</span><br></pre></td></tr></table></figure><p>输入root用户的新密码并确认。（密码要牢记！）</p><p>然后退出容器。然后基于这个容器提交新的镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit  -m 'my network example' network-example net:v1.0</span><br></pre></td></tr></table></figure><blockquote><p>说明：</p><ul><li>-m参数是添加一个说明</li><li>然后是容器名或id</li><li>最后是新镜像名和标签</li></ul></blockquote><h4 id="端口暴露"><a href="#端口暴露" class="headerlink" title="端口暴露"></a>端口暴露</h4><p>使用<code>-p</code>参数进行端口映射，格式如下：</p><blockquote><p>-p hostPort：containerPort 映射所有ip地址上的指定端口到容器内部</p><p>-p  ip:hostPort:containerPort 映射指定ip地址上的指定端口到容器内部</p><p>-p ip::containerPort  映射指定ip上的任意端口到容器内部</p></blockquote><p>比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -ti --name web -p 80:80 net:v1.0 bash</span><br></pre></td></tr></table></figure><p>这个命令启动一个容器，并映射宿主机所有ip的80端口到容器的80端口。</p><p>我们已经安装了apache服务器，启动它：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apache2ctl start</span><br></pre></td></tr></table></figure><p>然后查看容器的ip地址：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure><p><a href="https://i.loli.net/2018/04/14/5ad1b93b4e7e4.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/04/14/5ad1b93b4e7e4.png" alt="net-work.png"></a></p><p>这里我的是172.17.0.4，此时打开宿主机的浏览器，输入url:172.17.0.4，就可以访问到apache服务器的主页了。</p><p>端口暴露不仅可以把容器作为Web服务器使用，还可以通过网络让不同的容器相互通信。Docker默认使用tcp协议在容器间进行网络通信。如果要使用udp，可以使用如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -ti --name web -p 80:80/ud net:v1.0 bash</span><br></pre></td></tr></table></figure><h4 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h4><p>容器互联可以不使用端口暴露就让容器之间可以相互通信。</p><p>首先，创建一个源容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -ti -d --name source net:v1.0</span><br></pre></td></tr></table></figure><p>然后运行另一个容器，使用–link参数连接第一个容器:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -ti --name receiver --link source:sender net:v1.0 bash</span><br></pre></td></tr></table></figure><p>这里的–link source:sender 的意思是把名为source的容器连接到别名sender，然后就可在第二个容器以sender这个名字和第一个容器通信，比如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping sender</span><br></pre></td></tr></table></figure><p>因为系统把这个别名添加到了<code>/etc/hosts</code>中。</p><h4 id="SSH登录容器"><a href="#SSH登录容器" class="headerlink" title="SSH登录容器"></a>SSH登录容器</h4><p>首先运行一个容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -ti --name ssh -p 6667:22 net:v1.0 bash</span><br></pre></td></tr></table></figure><p>然后在容器里启动ssh服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service ssh start</span><br></pre></td></tr></table></figure><p>查看ip地址：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure><p><a href="https://i.loli.net/2018/04/14/5ad1be908a2d3.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/04/14/5ad1be908a2d3.png" alt="ifconfig.png"></a></p><p>然后在新的终端里运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@172.17.0.5</span><br></pre></td></tr></table></figure><p>然后就可以顺利进入容器了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;查看有哪些镜像：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker images&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;获取镜像：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker pull ubuntu:16.04&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="docker" scheme="http://www.idlforever.cn/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Redis主从复制</title>
    <link href="http://www.idlforever.cn/2018/03/28/Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    <id>http://www.idlforever.cn/2018/03/28/Redis主从复制/</id>
    <published>2018-03-28T00:00:31.000Z</published>
    <updated>2018-04-14T09:24:29.525Z</updated>
    
    <content type="html"><![CDATA[<p>Redis是一个开源（BSD许可），内存存储的数据结构服务器，可用作数据库，高速缓存和消息队列代理。它支持字符串、哈希表、列表、集合、有序集合，位图，hyperloglogs等数据类型。内置复制、Lua脚本、LRU收回、事务以及不同级别磁盘持久化功能，同时通过Redis Sentinel提供高可用，通过Redis Cluster提供自动分区。</p><a id="more"></a><h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><p>持久化就是把内存中的数据写到磁盘中，防止服务宕机。</p><ul><li>RDB   (默认)</li><li>AOF</li></ul><h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><p>RDB功能的核心函数<code>rdbSave</code>方法生成RDB文件，<code>rdbLoad</code>方法加载文件到内存。</p><p><strong>rdbSave方法</strong>：将内存中的数据以RDB格式保存到磁盘中，如果文件已经存在，那么新的RDB文件将会覆盖已有的RDB文件。保存期间，主进程会被阻塞，知道保存完成。</p><p><strong>save</strong>直接调用rdbSave，阻塞主线程。</p><p><strong>bgSave</strong>则fork出一个子进程，调用rdbSave，并在保存完成后向主进程发送信号，通知保存完成。</p><p><strong>存储结构：</strong></p><p><strong>保存策略：</strong></p><ul><li>save  900   1</li><li>save   300   10     // 300秒内容如果超过10个key被修改，则发起快照保存</li><li>save  60  10000 </li></ul><h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><p>AOF是Append-only-file的缩写。</p><p>服务器定时任务调用<code>flushAppendOnlyFile</code>函数，该函数完成下面两个工作：</p><ul><li><p>aof写入保存：</p><ul><li>write：根据条件，将<code>aof_buf</code>中的缓存写入到AOF文件</li><li>save：根据条件，调用<code>fsync</code>或者<code>fdatasync</code>函数，将AOF文件保存到磁盘中。</li></ul></li><li><p>保存策略：</p><p>| 模式               | write是否阻塞 | save是否阻塞 | 停机时丢失数据量                |<br>| —————— | ————- | ———— | ——————————- |<br>| AOF_FSYNC_NO       | 阻塞          | 阻塞         | 最后一次对AOF进行save之后的数据 |<br>| AOF_FSYNC_EVERYSEC | 阻塞          | 不阻塞       | 不超过2秒钟的数据               |<br>| AOF_FSYNC_ALWAYS   | 阻塞          | 阻塞         | 丢失一个命令的数据              |</p></li></ul><p><strong>存储结构：</strong></p><p>内容是Redis通讯协议（RESP）格式的命令文本存储。</p><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p>通常为被复制方（master）主动向复制方（slave）发送数据，主要目的是为了保证双方数据一致性，做备份容灾，并且分摊master的压力。</p><h4 id="主从复制实战"><a href="#主从复制实战" class="headerlink" title="主从复制实战"></a>主从复制实战</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cp redis.conf redis-slave1.conf</span><br><span class="line">vim redis-slave1.conf</span><br><span class="line">/slaveof         # 搜索到slaveof</span><br><span class="line">slaveof 127.0.0.1 6379     # master ip及端口</span><br><span class="line">/port 6379    # 搜索到port端口 并更改为6380</span><br><span class="line"><span class="meta">#</span> 保存退出</span><br><span class="line"><span class="meta">#</span> 修改master bind</span><br><span class="line">vim redis.conf</span><br><span class="line">/bind    # 搜索bind改为如下</span><br><span class="line">bind 0.0.0.0</span><br><span class="line"><span class="meta">#</span> 保存退出</span><br><span class="line"><span class="meta">#</span> 分别启动两个redis服务</span><br><span class="line">./src/redis-server redis.conf $</span><br><span class="line">./src/redis-server redis-slave1.conf $</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis是一个开源（BSD许可），内存存储的数据结构服务器，可用作数据库，高速缓存和消息队列代理。它支持字符串、哈希表、列表、集合、有序集合，位图，hyperloglogs等数据类型。内置复制、Lua脚本、LRU收回、事务以及不同级别磁盘持久化功能，同时通过Redis Sentinel提供高可用，通过Redis Cluster提供自动分区。&lt;/p&gt;
    
    </summary>
    
    
      <category term="redis" scheme="http://www.idlforever.cn/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>分布式事务</title>
    <link href="http://www.idlforever.cn/2018/03/24/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    <id>http://www.idlforever.cn/2018/03/24/分布式事务/</id>
    <published>2018-03-24T17:36:40.000Z</published>
    <updated>2018-04-14T09:24:29.525Z</updated>
    
    <content type="html"><![CDATA[<p><strong>什么是事务</strong></p><p>事务是指一组业务操作，要么全部成功，要么全部失败。<br><a id="more"></a></p><p><strong>事务的四大特性</strong></p><ul><li><p>原子性</p><ul><li>事务中的所有操作要么全部成功，要么全部失败。</li></ul></li><li><p>一致性（Consistency）</p><ul><li>事务必须是数据库从一个一致性状态转变到另一个一致性状态。</li></ul></li><li><p>隔离性</p><ul><li>事务的执行相互独立的，他们不会相互干扰。</li></ul></li><li><p>持久性</p><ul><li>每一次事务提交后就保证不会丢失。</li></ul><p>​</p></li></ul><p><strong>事务并发执行存在的问题</strong></p><ul><li>脏读<ul><li>一个事务读到另一个事务中未提交的数据，该数据有可能被回滚。</li><li>只会出现在read uncommited隔离级别，因为该隔离级别不对读事务设置锁，并且对写事务只设置行级共享锁。</li></ul></li><li>不可重复读<ul><li>一个事务对同一行数据读取两次却得到了不同的结果。</li><li>-T1–R1–T2–W1–T2–R2-   </li><li>R1读完后释放了锁，这时候事务T2对数据进行更改，这时候R2读取到的数据与R1又不一样了。</li></ul></li><li>幻读<ul><li>-T1–R1–T2–C–T2–R2–T1-</li><li>R1，R2表示读整个表，C表示T2事务新增一行记录。则在事务T1内两次读取表，得到不一样的数据。</li></ul></li><li>更新丢失<ul><li>当有两个事务同时更新同一条数据，有可能一个事务把 另一个事务的更新覆盖掉。</li></ul></li></ul><p><strong>事务的四中隔离级别</strong></p><ul><li><p><strong>read uncommitted</strong> </p><p>不对读事务设置锁，对写事务设置行级共享锁</p></li><li><p><strong>read commited</strong></p><p>对读事务设置行级共享锁，读完就释放；</p><p>对写事务设置行级互斥锁，知道事务结束才释放。</p></li><li><p><strong>repeatable read</strong></p><p>对读事务设置行级共享锁，直到事务结束后才释放；</p><p>对写事务设置行级互斥锁，直到事务结束后才释放；</p></li><li><p><strong>Serializable</strong></p><p>所有事务串行执行，读事务设置表级共享锁；</p><p>写事务设置表级互斥锁；</p></li></ul><h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><blockquote><p>分布式事务是指会涉及到操作多个数据库的事务。其实就是将对同一库事务的概念扩大到了对多个库的事务。目的是为了保证分布式系统中的数据一致性。分布式事务处理的关键是必须有一种方法可以知道事务在任何地方所做的所有动作，提交或回滚事务的决定必须产生统一的结果（全部提交或全部回滚）</p></blockquote><p>随着微服务架构的普及，一个大型业务系统往往由若干个子系统构成，这些子系统又拥有各自独立的数据库。往往一个业务流程需要由多个子系统共同完成，而且这些操作可能需要在一个事务中完成。此时，我们就需要在数据库之上通过某种手段，实现支持跨数据库的事务支持，这也就是大家常说的“分布式事务”。</p><p><strong>CAP理论</strong></p><p>一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。</p><ul><li>C：Consistency 一致性<ul><li>一致性指“<code>all nodes see the same data at the same time</code>”，即所有节点在同一时间的数据完全一致。</li></ul></li><li>A：Availability 可用性<ul><li>可用性指“<code>Reads and writes always succeed</code>”，即服务在正常响应时间内一直可用。</li></ul></li><li>P：Partition Tolerance 分区容忍性<ul><li>分区容错性指“<code>the system continues to operate despite arbitrary message loss or failure of part of the system</code>”，即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性或可用性的服务。</li></ul></li></ul><p><strong>BASE理论</strong></p><p>CAP理论告诉我们一个悲惨但不得不接受的事实——我们只能在C、A、P中选择两个条件。而对于业务系统而言，我们往往选择牺牲一致性来换取系统的可用性和分区容错性。不过这里要指出的是，所谓的“牺牲一致性”并不是完全放弃数据一致性，而是牺牲<strong>强一致性</strong>换取<strong>弱一致性</strong>。下面来介绍下BASE理论。</p><ul><li><p>BA：Basic Available——基本可用</p><p>整个系统在某些不可抗力的情况下，仍然能够保证“可用性”，即一定时间内仍然能够返回一个明确的结果。只不过“基本可用”和“高可用”的区别是：</p><ul><li>“一定时间”可以适当延长：当举行大促时，响应时间可以适当延长。</li><li>给部分用户返回一个降级页面：给部分用户直接返回一个降级页面，从而缓解服务器压力。但要注意，返回降级页面仍然是返回明确结果。</li></ul></li><li><p>S：Soft State——柔韧性状态</p><ul><li>同一数据的不同副本的状态，可以不需要实时一致。</li></ul></li><li><p>E：Eventual Consistency——最终一致性</p><ul><li>同一数据的不同副本的状态，可以不需要实时一致，但一定要保证经过一定时间后仍然是一致的。</li></ul></li></ul><h3 id="分布式事务协议"><a href="#分布式事务协议" class="headerlink" title="分布式事务协议"></a>分布式事务协议</h3><h4 id="两段提交协议2PC"><a href="#两段提交协议2PC" class="headerlink" title="两段提交协议2PC"></a>两段提交协议2PC</h4><p>分布式系统的一个难点是如何保证架构下多个节点在进行事务性操作的时候保持一致性。为实现这个目的，二阶段提交算法的成立基于以下假设：</p><ul><li>该分布式系统中，存在一个节点作为协调者(Coordinator)，其他节点作为参与者(Cohorts)。且节点之间可以进行网络通信。</li><li>所有节点都采用预写式日志，且日志被写入后即被保持在可靠的存储设备上，即使节点损坏不会导致日志数据的消失。</li><li>所有节点不会永久性损坏，即使损坏后仍然可以恢复。</li></ul><p><img src="https://i.loli.net/2018/03/24/5ab609a809e55.png" alt="2pc-success.png"></p><p><img src="https://i.loli.net/2018/03/24/5ab60af072a8b.png" alt="2pc-fail.png"></p><h5 id="第一阶段（投票阶段）"><a href="#第一阶段（投票阶段）" class="headerlink" title="第一阶段（投票阶段）"></a>第一阶段（投票阶段）</h5><ol><li>协调者节点向所有参与者节点询问是否可以执行提交操作(vote)，并开始等待各参与者节点的响应。</li><li>参与者节点执行询问发起为止的所有事务操作，并将Undo信息和Redo信息写入日志。（注意：若成功这里其实每个参与者已经执行了事务操作）</li><li>各参与者节点响应协调者节点发起的询问。如果参与者节点的事务操作实际执行成功，则它返回一个”同意”消息；如果参与者节点的事务操作实际执行失败，则它返回一个”中止”消息。</li></ol><h5 id="第二阶段（提交执行阶段）："><a href="#第二阶段（提交执行阶段）：" class="headerlink" title="第二阶段（提交执行阶段）："></a>第二阶段（提交执行阶段）：</h5><p>当协调者节点从所有参与者节点获得的相应消息都为”同意”时：</p><ol><li>协调者节点向所有参与者节点发出”正式提交(commit)”的请求。</li><li>参与者节点正式完成操作，并释放在整个事务期间内占用的资源。</li><li>参与者节点向协调者节点发送”完成”消息。</li><li>协调者节点受到所有参与者节点反馈的”完成”消息后，完成事务。</li></ol><p>如果任一参与者节点在第一阶段返回的响应消息为”中止”，或者 协调者节点在第一阶段的询问超时之前无法获取所有参与者节点的响应消息时：</p><ol><li>协调者节点向所有参与者节点发出”回滚操作(rollback)”的请求。</li><li>参与者节点利用之前写入的Undo信息执行回滚，并释放在整个事务期间内占用的资源。</li><li>参与者节点向协调者节点发送”回滚完成”消息。</li><li>协调者节点受到所有参与者节点反馈的”回滚完成”消息后，取消事务。</li></ol><p>不管最后结果如何，第二阶段都会结束当前事务。</p><p>二阶段提交看起来确实能够提供原子性的操作，但是不幸的事，二阶段提交还是有几个缺点的：</p><ol><li>执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。</li><li>参与者发生故障。协调者需要给每个参与者额外指定超时机制，超时后整个事务失败。（没有多少容错机制）</li><li>协调者发生故障。参与者会一直阻塞下去。需要额外的备机进行容错。（这个可以依赖后面要讲的Paxos协议实现HA）</li><li>二阶段无法解决的问题：协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。</li></ol><p>为此，Dale Skeen和Michael Stonebraker在“A Formal Model of Crash Recovery in a Distributed System”中提出了三阶段提交协议（3PC）。</p><h4 id="三阶段提交协议-3PC"><a href="#三阶段提交协议-3PC" class="headerlink" title="三阶段提交协议 3PC"></a>三阶段提交协议 3PC</h4><p>与两阶段提交不同的是，三阶段提交有两个改动点。</p><ul><li>引入超时机制。同时在协调者和参与者中都引入超时机制。</li><li>在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。</li></ul><p>也就是说，除了引入超时机制之外，3PC把2PC的准备阶段再次一分为二，这样三阶段提交就有CanCommit、PreCommit、DoCommit三个阶段。</p><p><img src="https://i.loli.net/2018/03/24/5ab6119edb90a.png" alt="3pc-success.png"></p><h5 id="CanCommit阶段"><a href="#CanCommit阶段" class="headerlink" title="CanCommit阶段"></a>CanCommit阶段</h5><p>3PC的CanCommit阶段其实和2PC的准备阶段很像。协调者向参与者发送commit请求，参与者如果可以提交就返回Yes响应，否则返回No响应。</p><p>（1）事务询问</p><p>协调者向参与者发送CanCommit请求。询问是否可以执行事务提交操作。然后开始等待参与者的响应。</p><p>（2）响应反馈</p><p>参与者接到CanCommit请求之后，正常情况下，如果其自身认为可以顺利执行事务，则返回Yes响应，并进入预备状态。否则反馈No</p><h5 id="PreCommit阶段"><a href="#PreCommit阶段" class="headerlink" title="PreCommit阶段"></a>PreCommit阶段</h5><p>协调者根据参与者的反应情况来决定是否可以记性事务的PreCommit操作。根据响应情况，有以下两种可能。假如协调者从所有的参与者获得的反馈都是Yes响应，那么就会执行事务的预执行。</p><p>（1）发送预提交请求</p><p>协调者向参与者发送PreCommit请求，并进入Prepared阶段。</p><p>（2）事务预提交</p><p>参与者接收到PreCommit请求后，会执行事务操作，并将undo和redo信息记录到事务日志中。</p><p>（3）响应反馈</p><p>如果参与者成功的执行了事务操作，则返回ACK响应，同时开始等待最终指令。</p><p>假如有任何一个参与者向协调者发送了No响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。</p><p>（4）发送中断请求 ：协调者向所有参与者发送abort请求。</p><p>（5）中断事务 ：参与者收到来自协调者的abort请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断。</p><h5 id="doCommit阶段"><a href="#doCommit阶段" class="headerlink" title="doCommit阶段"></a>doCommit阶段</h5><p>该阶段进行真正的事务提交，也可以分为以下两种情况。</p><ul><li><p>执行提交</p><ul><li><p>发送提交请求</p><p>协调接收到参与者发送的ACK响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送doCommit请求。</p></li><li><p>事务提交</p><p>参与者接收到doCommit请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。</p></li><li><p>响应反馈</p><p>事务提交完之后，向协调者发送Ack响应。</p></li><li><p>完成事务</p><p>协调者接收到所有参与者的ack响应之后，完成事务。</p></li></ul></li><li><p>中断事务</p><ul><li><p>发送中断请求</p><p>协调者向所有参与者发送abort请求</p></li><li><p>事务回滚</p><p>参与者接收到abort请求之后，利用其在阶段二记录的undo信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。</p></li><li><p>反馈结果</p><p>参与者完成事务回滚之后，向协调者发送ACK消息</p></li><li><p>中断事务</p><p>协调者接收到参与者反馈的ACK消息之后，执行事务的中断。</p></li></ul></li></ul><h3 id="分布式事务解决方案"><a href="#分布式事务解决方案" class="headerlink" title="分布式事务解决方案"></a>分布式事务解决方案</h3><p>分布式事务的解决方案有如下几种：</p><ul><li>全局消息</li><li>基于可靠消息服务的分布式事务</li><li>TCC</li><li>最大努力通知</li></ul><h4 id="全局事务（DTP消息）"><a href="#全局事务（DTP消息）" class="headerlink" title="全局事务（DTP消息）"></a>全局事务（DTP消息）</h4><p>全局事务基于DTP模型实现。DTP是由X/Open组织提出的一种分布式事务模型——X/Open Distributed Transaction Processing Reference Model。它规定了要实现分布式事务，需要三种角色：</p><p>（1）AP：Application 应用系统</p><p>它就是我们开发的业务系统，在我们开发的过程中，可以使用资源管理器提供的事务接口来实现分布式事务。</p><p>（2）TM：Transaction Manager 事务管理器</p><ul><li>分布式事务的实现由事务管理器来完成，它会提供分布式事务的操作接口供我们的业务系统调用。这些接口称为TX接口。</li><li>事务管理器还管理着所有的资源管理器，通过它们提供的XA接口来同一调度这些资源管理器，以实现分布式事务。</li><li>DTP只是一套实现分布式事务的规范，并没有定义具体如何实现分布式事务，TM可以采用2PC、3PC、Paxos等协议实现分布式事务。</li></ul><p>（3）RM：Resource Manager 资源管理器</p><ul><li>能够提供数据服务的对象都可以是资源管理器，比如：数据库、消息中间件、缓存等。大部分场景下，数据库即为分布式事务中的资源管理器。</li><li>资源管理器能够提供单数据库的事务能力，它们通过XA接口，将本数据库的提交、回滚等能力提供给事务管理器调用，以帮助事务管理器实现分布式的事务管理。</li><li>XA是DTP模型定义的接口，用于向事务管理器提供该资源管理器(该数据库)的提交、回滚等能力。</li><li>DTP只是一套实现分布式事务的规范，RM具体的实现是由数据库厂商来完成的。</li></ul><h4 id="基于可靠消息服务的分布式事务"><a href="#基于可靠消息服务的分布式事务" class="headerlink" title="基于可靠消息服务的分布式事务"></a>基于可靠消息服务的分布式事务</h4><p>通过消息中间件来实现。假设有A和B两个系统，分别可以处理任务A和任务B。此时系统A中存在一个业务流程，需要将任务A和任务B在同一个事务中处理。下面来介绍基于消息中间件来实现这种分布式事务。</p><p><img src="https://i.loli.net/2018/03/24/5ab61e46a51a1.png" alt="基于可靠消息服务的分布式事务.png"></p><ul><li>在系统A处理任务A前，首先向消息中间件发送一条消息</li><li>消息中间件收到后将该条消息持久化，但并不投递。此时下游系统B仍然不知道该条消息的存在。</li><li>消息中间件持久化成功后，便向系统A返回一个确认应答；</li><li>系统A收到确认应答后，则可以开始处理任务A；</li><li>任务A处理完成后，向消息中间件发送Commit请求。该请求发送完成后，对系统A而言，该事务的处理过程就结束了，此时它可以处理别的任务了。 但commit消息可能会在传输途中丢失，从而消息中间件并不会向系统B投递这条消息，从而系统就会出现不一致性。这个问题由消息中间件的事务回查机制完成，下文会介绍。</li><li>消息中间件收到Commit指令后，便向系统B投递该消息，从而触发任务B的执行；</li><li>当任务B执行完成后，系统B向消息中间件返回一个确认应答，告诉消息中间件该消息已经成功消费，此时，这个分布式事务完成。</li></ul><p>上述过程可以得出如下几个结论：</p><ol><li>消息中间件扮演者分布式事务协调者的角色。</li><li>系统A完成任务A后，到任务B执行完成之间，会存在一定的时间差。在这个时间差内，整个系统处于数据不一致的状态，但这短暂的不一致性是可以接受的，因为经过短暂的时间后，系统又可以保持数据一致性，满足BASE理论。</li></ol><p>上述过程中，如果任务A处理失败，那么需要进入回滚流程，如下图所示：</p><p><img src="https://i.loli.net/2018/03/24/5ab61e46c12d7.png" alt="基于可靠消息服务的分布式事务-fail.png"></p><ul><li>若系统A在处理任务A时失败，那么就会向消息中间件发送Rollback请求。和发送Commit请求一样，系统A发完之后便可以认为回滚已经完成，它便可以去做其他的事情。</li><li>消息中间件收到回滚请求后，直接将该消息丢弃，而不投递给系统B，从而不会触发系统B的任务B。</li></ul><blockquote><p>此时系统又处于一致性状态，因为任务A和任务B都没有执行。</p></blockquote><p>上面所介绍的Commit和Rollback都属于理想情况，但在实际系统中，Commit和Rollback指令都有可能在传输途中丢失。那么当出现这种情况的时候，消息中间件是如何保证数据一致性呢？——答案就是超时询问机制。</p><p><img src="https://i.loli.net/2018/03/24/5ab61e46e45dc.png" alt="基于可靠消息服务的分布式事务-超时回查.png"></p><p>系统A除了实现正常的业务流程外，还需提供一个事务询问的接口，供消息中间件调用。当消息中间件收到一条事务型消息后便开始计时，如果到了超时时间也没收到系统A发来的Commit或Rollback指令的话，就会主动调用系统A提供的事务询问接口询问该系统目前的状态。该接口会返回三种结果：</p><ul><li>提交：若获得的状态是“提交”，则将该消息投递给系统B。</li><li>回滚：若获得的状态是“回滚”，则直接将条消息丢弃。</li><li>处理中：若获得的状态是“处理中”，则继续等待。</li></ul><blockquote><p>消息中间件的超时询问机制能够防止上游系统因在传输过程中丢失Commit/Rollback指令而导致的系统不一致情况，而且能降低上游系统的阻塞时间，上游系统只要发出Commit/Rollback指令后便可以处理其他任务，无需等待确认应答。而Commit/Rollback指令丢失的情况通过超时询问机制来弥补，这样大大降低上游系统的阻塞时间，提升系统的并发度。</p></blockquote><p>下面来说一说消息投递过程的可靠性保证。</p><p>当上游系统执行完任务并向消息中间件提交了Commit指令后，便可以处理其他任务了，此时它可以认为事务已经完成，接下来消息中间件<strong>一定会保证消息被下游系统成功消费掉！</strong>那么这是怎么做到的呢？这由消息中间件的投递流程来保证。</p><p>消息中间件向下游系统投递完消息后便进入阻塞等待状态，下游系统便立即进行任务的处理，任务处理完成后便向消息中间件返回应答。消息中间件收到确认应答后便认为该事务处理完毕！</p><p>如果消息在投递过程中丢失，或消息的确认应答在返回途中丢失，那么消息中间件在等待确认应答超时之后就会重新投递，直到下游消费者返回消费成功响应为止。当然，一般消息中间件可以设置消息重试的次数和时间间隔，比如：当第一次投递失败后，每隔五分钟重试一次，一共重试3次。如果重试3次之后仍然投递失败，那么这条消息就需要人工干预。</p><p><img src="https://i.loli.net/2018/03/24/5ab61e46e5f97.png" alt="基于可靠消息服务的分布式事务-消息投递失败1.png"></p><p><img src="https://i.loli.net/2018/03/24/5ab61e46f0e13.png" alt="基于可靠消息服务的分布式事务-消息投递失败2.png"></p><blockquote><p>有的同学可能要问：消息投递失败后为什么不回滚消息，而是不断尝试重新投递？</p></blockquote><p>这就涉及到整套分布式事务系统的实现成本问题。我们知道，当系统A将向消息中间件发送Commit指令后，它便去做别的事情了。如果此时消息投递失败，需要回滚的话，就需要让系统A事先提供回滚接口，这无疑增加了额外的开发成本，业务系统的复杂度也将提高。对于一个业务系统的设计目标是，在保证性能的前提下，最大限度地降低系统复杂度，从而能够降低系统的运维成本。</p><blockquote><p>不知大家是否发现，上游系统A向消息中间件提交Commit/Rollback消息采用的是异步方式，也就是当上游系统提交完消息后便可以去做别的事情，接下来提交、回滚就完全交给消息中间件来完成，并且完全信任消息中间件，认为它一定能正确地完成事务的提交或回滚。然而，消息中间件向下游系统投递消息的过程是同步的。也就是消息中间件将消息投递给下游系统后，它会阻塞等待，等下游系统成功处理完任务返回确认应答后才取消阻塞等待。为什么这两者在设计上是不一致的呢？</p></blockquote><p>首先，上游系统和消息中间件之间采用异步通信是为了提高系统并发度。业务系统直接和用户打交道，用户体验尤为重要，因此这种异步通信方式能够极大程度地降低用户等待时间。此外，异步通信相对于同步通信而言，没有了长时间的阻塞等待，因此系统的并发性也大大增加。但异步通信可能会引起Commit/Rollback指令丢失的问题，这就由消息中间件的超时询问机制来弥补。</p><p>那么，消息中间件和下游系统之间为什么要采用同步通信呢？</p><p>异步能提升系统性能，但随之会增加系统复杂度；而同步虽然降低系统并发度，但实现成本较低。因此，在对并发度要求不是很高的情况下，或者服务器资源较为充裕的情况下，我们可以选择同步来降低系统的复杂度。 我们知道，消息中间件是一个独立于业务系统的第三方中间件，它不和任何业务系统产生直接的耦合，它也不和用户产生直接的关联，它一般部署在独立的服务器集群上，具有良好的可扩展性，所以不必太过于担心它的性能，如果处理速度无法满足我们的要求，可以增加机器来解决。而且，即使消息中间件处理速度有一定的延迟那也是可以接受的，因为前面所介绍的BASE理论就告诉我们了，我们追求的是最终一致性，而非实时一致性，因此消息中间件产生的时延导致事务短暂的不一致是可以接受的。</p><h4 id="最大努力通知（定期校对）"><a href="#最大努力通知（定期校对）" class="headerlink" title="最大努力通知（定期校对）"></a>最大努力通知（定期校对）</h4><p>最大努力通知也被称为定期校对，其实在方案二中已经包含，这里再单独介绍，主要是为了知识体系的完整性。这种方案也需要消息中间件的参与，其过程如下：</p><p><img src="https://i.loli.net/2018/03/24/5ab61e46e78f9.png" alt="最大努力通知.png"></p><ul><li>上游系统在完成任务后，向消息中间件同步地发送一条消息，确保消息中间件成功持久化这条消息，然后上游系统可以去做别的事情了；</li><li>消息中间件收到消息后负责将该消息同步投递给相应的下游系统，并触发下游系统的任务执行；</li><li>当下游系统处理成功后，向消息中间件反馈确认应答，消息中间件便可以将该条消息删除，从而该事务完成。</li></ul><p>上面是一个理想化的过程，但在实际场景中，往往会出现如下几种意外情况：</p><ol><li>消息中间件向下游系统投递消息失败</li><li>上游系统向消息中间件发送消息失败</li></ol><p>对于第一种情况，消息中间件具有重试机制，我们可以在消息中间件中设置消息的重试次数和重试时间间隔，对于网络不稳定导致的消息投递失败的情况，往往重试几次后消息便可以成功投递，如果超过了重试的上限仍然投递失败，那么消息中间件不再投递该消息，而是记录在失败消息表中，消息中间件需要提供失败消息的查询接口，下游系统会定期查询失败消息，并将其消费，这就是所谓的“定期校对”。</p><p>如果重复投递和定期校对都不能解决问题，往往是因为下游系统出现了严重的错误，此时就需要人工干预。</p><p>对于第二种情况，需要在上游系统中建立消息重发机制。可以在上游系统建立一张本地消息表，并将 <strong>任务处理过程</strong> 和 <strong>向本地消息表中插入消息</strong> 这两个步骤放在一个本地事务中完成。如果向本地消息表插入消息失败，那么就会触发回滚，之前的任务处理结果就会被取消。如果这量步都执行成功，那么该本地事务就完成了。接下来会有一个专门的消息发送者不断地发送本地消息表中的消息，如果发送失败它会返回重试。当然，也要给消息发送者设置重试的上限，一般而言，达到重试上限仍然发送失败，那就意味着消息中间件出现严重的问题，此时也只有人工干预才能解决问题。</p><p>对于不支持事务型消息的消息中间件，如果要实现分布式事务的话，就可以采用这种方式。它能够通过<strong>重试机制</strong>+<strong>定期校对</strong>实现分布式事务，但相比于第二种方案，它达到数据一致性的周期较长，而且还需要在上游系统中实现消息重试发布机制，以确保消息成功发布给消息中间件，这无疑增加了业务系统的开发成本，使得业务系统不够纯粹，并且这些额外的业务逻辑无疑会占用业务系统的硬件资源，从而影响性能。</p><p>因此，尽量选择支持事务型消息的消息中间件来实现分布式事务，如<code>RocketMQ</code>。</p><h4 id="TCC（两阶段型、补偿型）"><a href="#TCC（两阶段型、补偿型）" class="headerlink" title="TCC（两阶段型、补偿型）"></a>TCC（两阶段型、补偿型）</h4><p>TCC即为Try Confirm Cancel，它属于补偿型分布式事务。顾名思义，TCC实现分布式事务一共有三个步骤：</p><ul><li><p>Try：尝试待执行的业务</p></li><li><ul><li>这个过程并未执行业务，只是完成所有业务的一致性检查，并预留好执行所需的全部资源</li></ul></li><li><p>Confirm：执行业务</p></li><li><ul><li>这个过程真正开始执行业务，由于Try阶段已经完成了一致性检查，因此本过程直接执行，而不做任何检查。并且在执行的过程中，会使用到Try阶段预留的业务资源。</li></ul></li><li><p>Cancel：取消执行的业务</p></li><li><ul><li>若业务执行失败，则进入Cancel阶段，它会释放所有占用的业务资源，并回滚Confirm阶段执行的操作。</li></ul></li></ul><p>下面以一个转账的例子来解释下TCC实现分布式事务的过程。</p><blockquote><p>假设用户A用他的账户余额给用户B发一个100元的红包，并且余额系统和红包系统是两个独立的系统。</p></blockquote><ul><li><p>Try</p></li><li><ul><li>创建一条转账流水，并将流水的状态设为<strong>交易中</strong></li><li>将用户A的账户中扣除100元（预留业务资源）</li><li>Try成功之后，便进入Confirm阶段</li><li>Try过程发生任何异常，均进入Cancel阶段</li></ul></li><li><p>Confirm</p></li><li><ul><li>向B用户的红包账户中增加100元</li><li>将流水的状态设为<strong>交易已完成</strong></li><li>Confirm过程发生任何异常，均进入Cancel阶段</li><li>Confirm过程执行成功，则该事务结束</li></ul></li><li><p>Cancel</p></li><li><ul><li>将用户A的账户增加100元</li><li>将流水的状态设为<strong>交易失败</strong></li></ul></li></ul><p>在传统事务机制中，业务逻辑的执行和事务的处理，是在不同的阶段由不同的部件来完成的：业务逻辑部分访问资源实现数据存储，其处理是由业务系统负责；事务处理部分通过协调资源管理器以实现事务管理，其处理由事务管理器来负责。二者没有太多交互的地方，所以，传统事务管理器的事务处理逻辑，仅需要着眼于事务完成（commit/rollback）阶段，而不必关注业务执行阶段。</p><h5 id="TCC全局事务必须基于RM本地事务来实现全局事务"><a href="#TCC全局事务必须基于RM本地事务来实现全局事务" class="headerlink" title="TCC全局事务必须基于RM本地事务来实现全局事务"></a>TCC全局事务必须基于RM本地事务来实现全局事务</h5><p>TCC服务是由Try/Confirm/Cancel业务构成的， 其Try/Confirm/Cancel业务在执行时，会访问资源管理器（Resource Manager，下文简称RM）来存取数据。这些存取操作，必须要参与RM本地事务，以使其更改的数据要么都commit，要么都rollback。</p><p>这一点不难理解，考虑一下如下场景：</p><p><img src="https://i.loli.net/2018/03/24/5ab61e46dc4ff.png" alt="tcc.png"></p><p>假设图中的服务B没有基于RM本地事务（以RDBS为例，可通过设置auto-commit为true来模拟），那么一旦[B:Try]操作中途执行失败，TCC事务框架后续决定回滚全局事务时，该[B:Cancel]则需要判断[B:Try]中哪些操作已经写到DB、哪些操作还没有写到DB：假设[B:Try]业务有5个写库操作，[B:Cancel]业务则需要逐个判断这5个操作是否生效，并将生效的操作执行反向操作。</p><p>不幸的是，由于[B:Cancel]业务也有n（0&lt;=n&lt;=5）个反向的写库操作，此时一旦[B:Cancel]也中途出错，则后续的[B:Cancel]执行任务更加繁重。因为，相比第一次[B:Cancel]操作，后续的[B:Cancel]操作还需要判断先前的[B:Cancel]操作的n（0&lt;=n&lt;=5）个写库中哪几个已经执行、哪几个还没有执行，这就涉及到了幂等性问题。而对幂等性的保障，又很可能还需要涉及额外的写库操作，该写库操作又会因为没有RM本地事务的支持而存在类似问题。。。可想而知，如果不基于RM本地事务，TCC事务框架是无法有效的管理TCC全局事务的。</p><p>反之，基于RM本地事务的TCC事务，这种情况则会很容易处理：[B:Try]操作中途执行失败，TCC事务框架将其参与RM本地事务直接rollback即可。后续TCC事务框架决定回滚全局事务时，在知道“[B:Try]操作涉及的RM本地事务已经rollback”的情况下，根本无需执行[B:Cancel]操作。</p><p>换句话说，基于RM本地事务实现TCC事务框架时，一个TCC型服务的cancel业务要么执行，要么不执行，不需要考虑部分执行的情况。</p><h5 id="TCC事务框架应该提供Confirm-Cancel服务的幂等性保障"><a href="#TCC事务框架应该提供Confirm-Cancel服务的幂等性保障" class="headerlink" title="TCC事务框架应该提供Confirm/Cancel服务的幂等性保障"></a>TCC事务框架应该提供Confirm/Cancel服务的幂等性保障</h5><p>一般认为，服务的幂等性，是指针对同一个服务的多次(n&gt;1)请求和对它的单次(n=1)请求，二者具有相同的副作用。</p><p>在TCC事务模型中，Confirm/Cancel业务可能会被重复调用，其原因很多。比如，全局事务在提交/回滚时会调用各TCC服务的Confirm/Cancel业务逻辑。执行这些Confirm/Cancel业务时，可能会出现如网络中断的故障而使得全局事务不能完成。因此，故障恢复机制后续仍然会重新提交/回滚这些未完成的全局事务，这样就会再次调用参与该全局事务的各TCC服务的Confirm/Cancel业务逻辑。</p><p>既然Confirm/Cancel业务可能会被多次调用，就需要保障其幂等性。 那么，应该由TCC事务框架来提供幂等性保障？还是应该由业务系统自行来保障幂等性呢？</p><p>个人认为，应该是由TCC事务框架来提供幂等性保障。如果仅仅只是极个别服务存在这个问题的话，那么由业务系统来负责也是可以的；然而，这是一类公共问题，毫无疑问，所有TCC服务的Confirm/Cancel业务存在幂等性问题。TCC服务的公共问题应该由TCC事务框架来解决；而且，考虑一下由业务系统来负责幂等性需要考虑的问题，就会发现，这无疑增大了业务系统的复杂度。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;什么是事务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;事务是指一组业务操作，要么全部成功，要么全部失败。&lt;br&gt;
    
    </summary>
    
    
      <category term="分布式" scheme="http://www.idlforever.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>TreeMap源码分析</title>
    <link href="http://www.idlforever.cn/2018/03/16/TreeMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://www.idlforever.cn/2018/03/16/TreeMap源码分析/</id>
    <published>2018-03-16T23:39:02.000Z</published>
    <updated>2018-04-14T09:24:29.525Z</updated>
    
    <content type="html"><![CDATA[<p><code>TreeMap</code>是基于红黑树实现的。并且实现了<code>SortedMap</code>接口，是可排序的，如果构造器没有传入比较器，则根据键按自然排序。<code>TreeMap</code>并不是线程安全的，如果高并发写的情况下需要开发人员自行实现同步，或者通过以下代码，包装成一个同步的<code>SortedMap</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SortedMap map = Collections.synchronizedSortedMap(<span class="keyword">new</span> TreeMap());</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="TreeMap的类结构图："><a href="#TreeMap的类结构图：" class="headerlink" title="TreeMap的类结构图："></a>TreeMap的类结构图：</h2><p><a href="https://i.loli.net/2018/03/16/5aabc82119ae3.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/03/16/5aabc82119ae3.png" alt="TreeMap-Class-Structure.png"></a></p><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Red-black mechanics</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> RED   = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> BLACK = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> K&gt; comparator;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;K,V&gt; root;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><code>TreeMap</code>中有个Entry内部类，封装了红黑数的数据结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    Entry&lt;K,V&gt; left;</span><br><span class="line">    Entry&lt;K,V&gt; right;</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="keyword">boolean</span> color = BLACK;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="核心方法解析"><a href="#核心方法解析" class="headerlink" title="核心方法解析"></a>核心方法解析</h2><p><strong>左旋：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rotateLeft</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; r = p.right;</span><br><span class="line">        p.right = r.left;</span><br><span class="line">        <span class="keyword">if</span> (r.left != <span class="keyword">null</span>)</span><br><span class="line">            r.left.parent = p;</span><br><span class="line">        r.parent = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line">            root = r;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p.parent.left == p)</span><br><span class="line">            p.parent.left = r;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p.parent.right = r;</span><br><span class="line">        r.left = p;</span><br><span class="line">        p.parent = r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>右旋：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rotateRight</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; l = p.left;</span><br><span class="line">        p.left = l.right;</span><br><span class="line">        <span class="keyword">if</span> (l.right != <span class="keyword">null</span>) l.right.parent = p;</span><br><span class="line">        l.parent = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line">            root = l;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p.parent.right == p)</span><br><span class="line">            p.parent.right = l;</span><br><span class="line">        <span class="keyword">else</span> p.parent.left = l;</span><br><span class="line">        l.right = p;</span><br><span class="line">        p.parent = l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>左旋和右旋的代码很简单，看不懂的请先去看看红黑树剖析一文。</p><p>下面分析下TreeMap中的最核心的一些查找方法，快速查找，才是TreeMap的灵魂。先来看看TreepMap中都有哪些查找方法：</p><p><a href="https://i.loli.net/2018/03/16/5aabcbee1caee.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/03/16/5aabcbee1caee.png" alt="TreeMap中的查找方法.png"></a></p><p>先从<code>V get(Object key)</code>这个方法看起：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line">    <span class="keyword">return</span> (p==<span class="keyword">null</span> ? <span class="keyword">null</span> : p.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>当指定的key不能被比较时，会抛出<code>ClassCastException</code></li><li>当<code>TreeMap</code>采用key自然排序并且指定key为<code>Null</code>，或者比较器不允许<code>Null</code>值时，会抛出<code>NullPointerException</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Offload comparator-based version for sake of performance</span></span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getEntryUsingComparator(key);</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</span><br><span class="line">    Entry&lt;K,V&gt; p = root;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = k.compareTo(p.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            p = p.left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            p = p.right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过二叉树查找，遍历结点，查找和key值相等Entry，如果找不到，返回Null。</p><ul><li>插入方法put()</li></ul><p>put(K key, V value)方法是将指定的键值对添加到map里，如果key已经存在，则替换原来的value，返回oldValue，如果不存在，则在红黑数中查找到合适的位置进行插入，如果插入后破坏了红黑树规则，则进行调整。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">int</span> cmp;</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;<span class="comment">//使用元素的自然顺序</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        parent = t;</span><br><span class="line">        cmp = k.compareTo(t.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) t = t.left;<span class="comment">//向左找</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) t = t.right;<span class="comment">//向右找</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">    &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(key, value, parent);<span class="comment">//创建并插入新的entry</span></span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) parent.left = e;</span><br><span class="line">    <span class="keyword">else</span> parent.right = e;</span><br><span class="line">    fixAfterInsertion(e);<span class="comment">//调整</span></span><br><span class="line">    size++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来看看关键的<code>fixAfterInsertion()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterInsertion</span><span class="params">(Entry&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    x.color = RED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="keyword">null</span> &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x)));</span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(y, BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                x = parentOf(parentOf(x));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == rightOf(parentOf(x))) &#123;</span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">                    rotateLeft(x);</span><br><span class="line">                &#125;</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                rotateRight(parentOf(parentOf(x)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x)));</span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(y, BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                x = parentOf(parentOf(x));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">                    rotateRight(x);</span><br><span class="line">                &#125;</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                rotateLeft(parentOf(parentOf(x)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    root.color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;TreeMap&lt;/code&gt;是基于红黑树实现的。并且实现了&lt;code&gt;SortedMap&lt;/code&gt;接口，是可排序的，如果构造器没有传入比较器，则根据键按自然排序。&lt;code&gt;TreeMap&lt;/code&gt;并不是线程安全的，如果高并发写的情况下需要开发人员自行实现同步，或者通过以下代码，包装成一个同步的&lt;code&gt;SortedMap&lt;/code&gt;：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;SortedMap map = Collections.synchronizedSortedMap(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; TreeMap());&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="JDK源码" scheme="http://www.idlforever.cn/tags/JDK%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>红黑树深入剖析</title>
    <link href="http://www.idlforever.cn/2018/03/14/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90/"/>
    <id>http://www.idlforever.cn/2018/03/14/红黑树深入剖析/</id>
    <published>2018-03-14T18:57:32.000Z</published>
    <updated>2018-04-14T09:24:29.525Z</updated>
    
    <content type="html"><![CDATA[<p>红黑数是一种平衡的二叉搜索树，因此我们从二叉树开始讨论。</p><p><strong>BST</strong></p><p>二叉查找树（BST）是一二叉树，左节点比父结点的值小。因此，查找的复杂度取决于树的高度，理想情况下，二叉树的增删改查的时间复杂度是O（logN）（N为结点数），最坏的情况下是O（N）,当高度为logN+1得时候，这颗二叉树就是平衡二叉树。</p><a id="more"></a><p><strong>BST存在的缺陷</strong></p><p>不同的插入顺序导致树的的高度不同，查找的复杂度就会差异很大，假如所有几点都在一条斜线上，那么高度是N。</p><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><ul><li>结点非黑即白。</li><li>根结点是黑色的。</li><li>每个叶子结点都是黑色的。</li><li>每个红色结点的两个子结点都是黑色的。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</li><li>每个结点向下遍历到其子孙 结点，所经过的黑色结点数相同。</li></ul><p>下图中的树，就是一个棵典型的红黑数：</p><p><a href="https://i.loli.net/2018/03/16/5aab6c30e4ca3.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/03/16/5aab6c30e4ca3.png" alt="红黑树.png"></a></p><h4 id="红黑数的数据结构"><a href="#红黑数的数据结构" class="headerlink" title="红黑数的数据结构"></a>红黑数的数据结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> RED   = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> BLACK = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Node</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">      T value;</span><br><span class="line">      Node&lt;T&gt; parent;</span><br><span class="line">      <span class="keyword">boolean</span> color = BLACK;</span><br><span class="line">      Node&lt;T&gt; left;</span><br><span class="line">      Node&lt;T&gt; right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="红黑数的变色和旋转"><a href="#红黑数的变色和旋转" class="headerlink" title="红黑数的变色和旋转"></a>红黑数的变色和旋转</h4><p>变色和旋转是为了使得红黑树符合其原本的性质。</p><p>上图中，我们向红黑树中插入一个数21时：</p><p><a href="https://i.loli.net/2018/03/16/5aab6d72433dd.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/03/16/5aab6d72433dd.png" alt="规则破坏.png"></a></p><p>就破坏了路径上不能存在连续两个红色结点的性质。</p><p><strong>变色：</strong></p><p>为了重新符合红黑树的性质，尝试把红色节点变为黑色，或者把黑色节点变为红色。</p><p>先把22结点变成黑色。</p><p><a href="https://i.loli.net/2018/03/16/5aab72f5cbb24.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/03/16/5aab72f5cbb24.png" alt="22结点变色.png"></a></p><p>继续把25结点变成红色。</p><p><a href="https://i.loli.net/2018/03/16/5aab734da8d16.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/03/16/5aab734da8d16.png" alt="25结点变色.png"></a></p><p>依然不符合规则，继续将27结点变色。</p><p><a href="https://i.loli.net/2018/03/16/5aab7383a7930.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/03/16/5aab7383a7930.png" alt="27结点变色.png"></a></p><p><strong>左旋：</strong></p><p><strong>逆时针</strong>旋转两个结点，使得父节点被右孩子取代，自己成为自己的左孩子。如图：</p><p><a href="https://i.loli.net/2018/03/16/5aab6f837ec97.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/03/16/5aab6f837ec97.png" alt="左旋.png"></a></p><p><strong>右旋：</strong></p><p><strong>顺时针</strong>旋转两个子结点，使得父节点被左孩子取代，自己成为自己的右孩子。如图：</p><p><a href="https://i.loli.net/2018/03/16/5aab70cbd2ff7.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/03/16/5aab70cbd2ff7.png" alt="右旋.png"></a></p><p>经过上面的变色，现在仍然不符合规则：</p><p><a href="https://i.loli.net/2018/03/16/5aab73dca6882.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/03/16/5aab73dca6882.png" alt="无法变色.png"></a></p><p>此时如果继续变色，将17变为黑色，13变为红色，就打破了根结点必须是黑色的规则。所以，该是旋转上场的时候了^o^….</p><p>13结点和17结点左旋：</p><p><a href="https://i.loli.net/2018/03/16/5aab75476094d.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/03/16/5aab75476094d.png" alt="根结点左旋.png"></a></p><p>接着，变色：</p><p><a href="https://i.loli.net/2018/03/16/5aab75811baf2.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/03/16/5aab75811baf2.png" alt="左旋后变色.png"></a></p><p>这样依然没有结束，17-&gt;8-&gt;6-&gt;NIL的黑色结点数是4，而根结点到其他的叶子节点的黑色结点数为3,所以，对13结点和8结点进行右旋：</p><p><a href="https://i.loli.net/2018/03/16/5aab77b9adc92.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/03/16/5aab77b9adc92.png" alt="13和8结点右旋.png"></a></p><p>然后变色：</p><p><a href="https://i.loli.net/2018/03/16/5aab7818e7309.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/03/16/5aab7818e7309.png" alt="result.png"></a></p><p>至此，插入修复操作便完成了，整个数依然符合红黑树的性质。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;红黑数是一种平衡的二叉搜索树，因此我们从二叉树开始讨论。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;BST&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;二叉查找树（BST）是一二叉树，左节点比父结点的值小。因此，查找的复杂度取决于树的高度，理想情况下，二叉树的增删改查的时间复杂度是O（logN）（N为结点数），最坏的情况下是O（N）,当高度为logN+1得时候，这颗二叉树就是平衡二叉树。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://www.idlforever.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC上下文初始化</title>
    <link href="http://www.idlforever.cn/2018/03/12/SpringMVC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://www.idlforever.cn/2018/03/12/SpringMVC源码分析/</id>
    <published>2018-03-12T18:34:52.000Z</published>
    <updated>2018-04-14T09:24:29.525Z</updated>
    
    <content type="html"><![CDATA[<p><strong>quick start</strong></p><p><strong>在pom.xml中引入依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.11.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="配置Web-xml和application-xml"><a href="#配置Web-xml和application-xml" class="headerlink" title="配置Web.xml和application.xml"></a>配置Web.xml和application.xml</h3><p><code>web.xml</code>:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring-mvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>spring<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring-mvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>spring<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>spring-mvc.xml:</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.bestcode.springmvc.controller"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>&gt;</span><span class="tag">&lt;/<span class="name">context:annotation-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Controller代码"><a href="#Controller代码" class="headerlink" title="Controller代码"></a>Controller代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/index"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello , Spring Mvc"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SpringMVC核心——DispatcherServlet"><a href="#SpringMVC核心——DispatcherServlet" class="headerlink" title="SpringMVC核心——DispatcherServlet"></a>SpringMVC核心——DispatcherServlet</h2><h3 id="DispatcherServlet架构图"><a href="#DispatcherServlet架构图" class="headerlink" title="DispatcherServlet架构图"></a>DispatcherServlet架构图</h3><p><a href="https://i.loli.net/2018/03/15/5aaa1720f094f.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/03/15/5aaa1720f094f.png" alt="DispatcherServlet.png"></a></p><p>可以看到三个核心类<code>DispatcherServlet</code>，<code>FramewordServlet</code>，<code>HttpServletBean</code>，我们先来看<code>HttpServlet</code>的直接子类<code>HttpServletBean</code>都做了哪些事：</p><p><code>HttpServletBean</code>类的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpServletBean</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> <span class="keyword">implements</span> <span class="title">EnvironmentCapable</span>, <span class="title">EnvironmentAware</span></span></span><br></pre></td></tr></table></figure><p><a href="https://i.loli.net/2018/03/15/5aaa1a04efc12.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/03/15/5aaa1a04efc12.png" alt="HttpServletBean.png"></a></p><p><code>HttpServletBean</code>中的核心<code>init</code>方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">"Initializing servlet '"</span> + getServletName() + <span class="string">"'"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 从init-param中解析contextConfigLocation，加载spring配置文件</span></span><br><span class="line">   PropertyValues pvs = <span class="keyword">new</span> ServletConfigPropertyValues(getServletConfig(), <span class="keyword">this</span>.requiredProperties);</span><br><span class="line">   <span class="keyword">if</span> (!pvs.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 包裹DispatcherServlet对象的BeanWrapperImpl</span></span><br><span class="line">         BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(<span class="keyword">this</span>);</span><br><span class="line">         <span class="comment">// 获取ServletContextResourceLoader</span></span><br><span class="line">         ResourceLoader resourceLoader = <span class="keyword">new</span> ServletContextResourceLoader(getServletContext());</span><br><span class="line">         bw.registerCustomEditor(Resource.class, <span class="keyword">new</span> ResourceEditor(resourceLoader, getEnvironment()));</span><br><span class="line">         initBeanWrapper(bw);</span><br><span class="line">         bw.setPropertyValues(pvs, <span class="keyword">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isErrorEnabled()) &#123;</span><br><span class="line">            logger.error(<span class="string">"Failed to set bean properties on servlet '"</span> + getServletName() + <span class="string">"'"</span>, ex);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Let subclasses do whatever initialization they like.</span></span><br><span class="line">   initServletBean();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">"Servlet '"</span> + getServletName() + <span class="string">"' configured successfully"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，容器启动的时候会加载spring配置元数据，注册用户自定义的property editor。</p><p>然后，初始化ServletBean，由子类负责实现，我们来看下FramewordServlet中的实现，在此之前我们先来看看FrameworkServlet中的一个非常重要的属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> WebApplicationContext webApplicationContext;</span><br></pre></td></tr></table></figure><p>下面是<code>WebApplicationContext</code>的类图：</p><p><img src="https://s1.ax2x.com/2018/03/15/L2mOO.png" alt="L2mOO.png"></p><p>这里终于看到了我们熟悉的IOC容器接口<code>ApplicationContext</code>，说明，容器的加载获取，这在这个方法中加载的。</p><p>那是不是就是这个<code>initServletBean</code>方法所做的事情呢，下面我们验证我们的猜想，看看<code>FrameworkServlet</code>中<code>initServletBean</code>到底怎么实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">initServletBean</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">   getServletContext().log(<span class="string">"Initializing Spring FrameworkServlet '"</span> + getServletName() + <span class="string">"'"</span>);</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isInfoEnabled()) &#123;</span><br><span class="line">      <span class="keyword">this</span>.logger.info(<span class="string">"FrameworkServlet '"</span> + getServletName() + <span class="string">"': initialization started"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 初始化WebApplicationContext 拿到WebApplicationContext的实现类XmlWebApplicationContext</span></span><br><span class="line">      <span class="keyword">this</span>.webApplicationContext = initWebApplicationContext();</span><br><span class="line">      initFrameworkServlet();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (ServletException ex) &#123;</span><br><span class="line">      <span class="keyword">this</span>.logger.error(<span class="string">"Context initialization failed"</span>, ex);</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">      <span class="keyword">this</span>.logger.error(<span class="string">"Context initialization failed"</span>, ex);</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isInfoEnabled()) &#123;</span><br><span class="line">      <span class="keyword">long</span> elapsedTime = System.currentTimeMillis() - startTime;</span><br><span class="line">      <span class="keyword">this</span>.logger.info(<span class="string">"FrameworkServlet '"</span> + getServletName() + <span class="string">"': initialization completed in "</span> +</span><br><span class="line">            elapsedTime + <span class="string">" ms"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到通过<code>initWebApplicationContext</code>方法获取到<code>WebApplicationConext</code>（<code>XmlWebApplicationContext</code>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">initWebApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   WebApplicationContext rootContext =</span><br><span class="line">         WebApplicationContextUtils.getWebApplicationContext(getServletContext());</span><br><span class="line">   WebApplicationContext wac = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.webApplicationContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// A context instance was injected at construction time -&gt; use it</span></span><br><span class="line">      wac = <span class="keyword">this</span>.webApplicationContext;</span><br><span class="line">      <span class="keyword">if</span> (wac <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;</span><br><span class="line">         ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;</span><br><span class="line">         <span class="keyword">if</span> (!cwac.isActive()) &#123;</span><br><span class="line">            <span class="comment">// The context has not yet been refreshed -&gt; provide services such as</span></span><br><span class="line">            <span class="comment">// setting the parent context, setting the application context id, etc</span></span><br><span class="line">            <span class="keyword">if</span> (cwac.getParent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">// The context instance was injected without an explicit parent -&gt; set</span></span><br><span class="line">               <span class="comment">// the root application context (if any; may be null) as the parent</span></span><br><span class="line">               cwac.setParent(rootContext);</span><br><span class="line">            &#125;</span><br><span class="line">            configureAndRefreshWebApplicationContext(cwac);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// No context instance was injected at construction time -&gt; see if one</span></span><br><span class="line">      <span class="comment">// has been registered in the servlet context. If one exists, it is assumed</span></span><br><span class="line">      <span class="comment">// that the parent context (if any) has already been set and that the</span></span><br><span class="line">      <span class="comment">// user has performed any initialization such as setting the context id</span></span><br><span class="line">      wac = findWebApplicationContext();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// No context instance is defined for this servlet -&gt; create a local one</span></span><br><span class="line">      wac = createWebApplicationContext(rootContext);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!<span class="keyword">this</span>.refreshEventReceived) &#123;</span><br><span class="line">      <span class="comment">// Either the context is not a ConfigurableApplicationContext with refresh</span></span><br><span class="line">      <span class="comment">// support or the context injected at construction time had already been</span></span><br><span class="line">      <span class="comment">// refreshed -&gt; trigger initial onRefresh manually here.</span></span><br><span class="line">      onRefresh(wac);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.publishContext) &#123;</span><br><span class="line">      <span class="comment">// Publish the context as a servlet context attribute.</span></span><br><span class="line">      String attrName = getServletContextAttributeName();</span><br><span class="line">      getServletContext().setAttribute(attrName, wac);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">         <span class="keyword">this</span>.logger.debug(<span class="string">"Published WebApplicationContext of servlet '"</span> + getServletName() +</span><br><span class="line">               <span class="string">"' as ServletContext attribute with name ["</span> + attrName + <span class="string">"]"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> wac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<code>wac==null</code>时，会调用<code>createWebApplicationContext(rootContext)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">createWebApplicationContext</span><span class="params">(ApplicationContext parent)</span> </span>&#123;</span><br><span class="line">   Class&lt;?&gt; contextClass = getContextClass();</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">      <span class="keyword">this</span>.logger.debug(<span class="string">"Servlet with name '"</span> + getServletName() +</span><br><span class="line">            <span class="string">"' will try to create custom WebApplicationContext context of class '"</span> +</span><br><span class="line">            contextClass.getName() + <span class="string">"'"</span> + <span class="string">", using parent context ["</span> + parent + <span class="string">"]"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(</span><br><span class="line">            <span class="string">"Fatal initialization error in servlet with name '"</span> + getServletName() +</span><br><span class="line">            <span class="string">"': custom WebApplicationContext class ["</span> + contextClass.getName() +</span><br><span class="line">            <span class="string">"] is not of type ConfigurableWebApplicationContext"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   ConfigurableWebApplicationContext wac =</span><br><span class="line">         (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line">   <span class="comment">// 设置环境，这里是StandardServletEnvironment</span></span><br><span class="line">   wac.setEnvironment(getEnvironment());</span><br><span class="line">   <span class="comment">// 设置父Context</span></span><br><span class="line">   wac.setParent(parent);</span><br><span class="line">   <span class="comment">// 设置配置位置：classpath:spring-mvc.xml</span></span><br><span class="line">   wac.setConfigLocation(getContextConfigLocation());</span><br><span class="line"></span><br><span class="line">   configureAndRefreshWebApplicationContext(wac);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> wac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;quick start&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在pom.xml中引入依赖&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-webmvc&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;4.3.11.RELEASE&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;javax.servlet&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;javax.servlet-api&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;3.1.0&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;provided&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="http://www.idlforever.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Angualr最佳实践</title>
    <link href="http://www.idlforever.cn/2018/03/10/Angualr%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>http://www.idlforever.cn/2018/03/10/Angualr最佳实践/</id>
    <published>2018-03-10T10:16:43.000Z</published>
    <updated>2018-04-14T09:24:29.525Z</updated>
    
    <content type="html"><![CDATA[<p>根据自身的项目经验，总结Angular的一些最佳实践，旨在提高开发效率，提高代码质量。<br><a id="more"></a></p><h2 id="单一职责"><a href="#单一职责" class="headerlink" title="单一职责"></a>单一职责</h2><ul><li>一个文件定义一样东西，比如一个组件、一个服务、一个管道、一个指令</li><li>每个文件最多不要超过400行</li><li>定义功能单一的函数</li><li>一个函数最多不要超过75行</li></ul><h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><ul><li>文件名采用feature.type.**，feature表示特性，type表示类型</li></ul><ul><li><ul><li>模块用 .module.ts</li><li>路由模块用 -routing.module.ts</li><li>组件用 .component.ts|html|css</li><li>服务用 .service.ts</li><li>管道用 .pipe.ts</li><li>指令用 .directive.ts</li><li>类型用 .model.ts</li><li>数据用 .data.ts</li></ul></li></ul><ul><li>用”-“来分割单词，比如hero-list.component.ts</li><li>单元测试文件名保持和测试对象一致，并以.spec.ts结尾</li><li>端到端测试文件名保持和测试对象一致，并以.e2e-spec.ts结尾</li><li>类名用大写驼峰规则，并且保持跟文件名的一致</li></ul><ul><li><ul><li>模块：比如app.module.ts定义的类名为AppModule</li><li>路由模块：比如app-routing.module.ts定义的类名为AppRoutingModule</li><li>组件：比如hero-list.component.ts定义的类名为HeroListComponent</li><li>服务：比如logger.service.ts定义的类名为LoggerService</li><li>管道：比如address.pipe.ts定义的类名为AddressPipe</li><li>指令：比如highlight.directive.ts定义的类名为HighlightDirective</li><li>类型：按模块来划分，一个.model.ts定义多个类型</li><li>数据：比如address-book.data.ts定义的变量名为addressBook</li></ul></li></ul><ul><li>指令选择器的命名采用小写驼峰规则，比如clickOutSide</li><li>组件选择器的命名采用分隔符“-”连接小写字母的形式，比如hero-list</li></ul><h2 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h2><ul><li>类命名采用大写驼峰规则</li><li>常量定义用const，并且全部大写，如果有多个单词，用“_”连接，比如HERO_URL</li><li>支持ES6的环境下，禁止使用var定义变量</li><li>变量命名尽量控制在3个单词以内，有常见缩写形式的单词可采用缩写形式</li><li>属性和方法名用小写驼峰，私有属性和方法不建议以“_”为前缀</li><li>建议用空一行的方式来区分第三方库的导入和项目本身文件的导入</li></ul><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><ul><li>为每个特性创建一个模块，并且保持文件夹命名和模块命名一致</li><li>共享模块建议用SharedModule命名，放在app/shared/shared.module.ts中</li><li>在共享模块中定义复用的组件、指令和管道，避免在共享模块中定义服务</li><li>在共享模块中导入所有必需的模块，比如CommonModule和FormsModule，导出所有复用的模块、组件、指令、管道</li><li>考虑将只用一次的类放在核心特性模块中，并且仅在根模块中导入，建议写guard.ts来保证</li><li>将单例服务放在核心特性模块中，比如ExceptionService和LoggerService</li><li>在核心特性模块中导入所有必需的模块，比如CommonModule和FormsModule，导出所有定义的组件，服务等</li><li>将全局仅用一次的组件放在核心特性模块，然后只在AppModule中导入，比如HeaderComponent和FooterComponent</li><li>独立的特性模块可以做成懒加载模块，避免在任何地方导入懒加载模块，不然模块就会直接加载</li></ul><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><ul><li>当模板／样式超过3行时，写成单独文件</li><li>删除无样式定义的样式文件</li><li>模板／样式的定义与组件命名保持一致</li><li>导入时使用相对路径</li><li>用装饰器@Input和@Output来修改输入输出数据，而不是使用元数据中的inputs和outputs属性</li><li>按照变量，构造器，生命周期函数，一般方法的顺序定义；一般方法按页面的功能模块放一起，被调用的方法写在后面；变量和方法均先公有后私有排列；</li><li>将可复用的业务逻辑放在服务中</li><li>将展示逻辑放在组件的类中，而不是在模板中</li></ul><h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><ul><li>跟函数一样，一个服务只有一个目的</li><li>把服务注入在最高层的组件／模块中，使得该单例服务能在子组件、子模块中共享</li><li>使用@Injectable装饰服务类，而不是@Inject装饰参数</li></ul><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ul><li>需要生命周期钩子时，实现相关的接口，可有效防止错误</li></ul><p>辅助工具</p><ul><li>使用IDE的代码片段工具来快速生成具有一致性的代码片段，比如给VS Code安装<a href="http://link.zhihu.com/?target=https%3A//marketplace.visualstudio.com/items%3FitemName%3Djohnpapa.Angular2" target="_blank" rel="noopener">snippets</a></li></ul><p>利用好TypeScript类型</p><ul><li>限制类型——通过枚举来代替</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Order &#123;  </span><br><span class="line">    status: <span class="string">'pending'</span> | <span class="string">'approved'</span> | <span class="string">'rejected'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Status &#123;</span><br><span class="line">  Pending = <span class="number">1</span>,</span><br><span class="line">  Approved = <span class="number">2</span>,</span><br><span class="line">  Rejected = <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Order &#123;</span><br><span class="line">  status: Statuses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>组件生命周期钩子：顺序-</li></ul><ol><li>ngOnChanges() ：当Angular（重新）设置数据绑定输入属性时响应。 </li></ol><p>该方法接受当前和上一属性值的SimpleChanges对象当被绑定的输入属性的值发生变化时调用，首次调用一定会发生在ngOnInit()之前。</p><ol><li>ngOnInit():在Angular第一次显示数据绑定和设置指令/组件的输入属性之后，初始化指令/组件。只调用一次</li><li>ngDoCheck():检测，并在发生Angular无法或不愿意自己检测的变化时作出反应。在每个Angular变更检测周期中调用，ngOnChanges()和ngOnInit()之后。</li><li>ngAfterContentInit()：当把内容投影进组件之后调用。第一次ngDoCheck()之后调用，只调用一次。只适用于组件。</li><li>ngAfterContentChecked()：每次完成被投影组件内容的变更检测之后调用。ngAfterContentInit()和每次ngDoCheck()之后调用只适合组件。</li><li>ngAfterViewInit()：初始化完组件视图及其子视图之后调用。第一次ngAfterContentChecked()之后调用，只调用一次。只适合组件。</li><li>ngAfterViewChecked()：每次做完组件视图和子视图的变更检测之后调用。ngAfterViewInit()和每次ngAfterContentChecked()之后调用。只适合组件。</li><li>ngOnDestroy：当Angular每次销毁指令/组件之前调用并清扫。 在这儿反订阅可观察对象和分离事件处理器，以防内存泄漏。在Angular销毁指令/组件之前调用。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;根据自身的项目经验，总结Angular的一些最佳实践，旨在提高开发效率，提高代码质量。&lt;br&gt;
    
    </summary>
    
    
      <category term="Angualr" scheme="http://www.idlforever.cn/tags/Angualr/"/>
    
  </entry>
  
  <entry>
    <title>Java代码规范</title>
    <link href="http://www.idlforever.cn/2018/03/07/Java%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <id>http://www.idlforever.cn/2018/03/07/Java代码规范/</id>
    <published>2018-03-07T19:02:00.000Z</published>
    <updated>2018-04-14T09:24:29.525Z</updated>
    
    <content type="html"><![CDATA[<p>代码拥有统一的格式和规范，既便于代码的逻辑清晰，又便于维护，好的编码规范可以尽可能的减少一个软件的维护成本。下面从三个方面进行约束：服务端口规范，方法命名规范，接口定义规范。</p><a id="more"></a><h3 id="服务端口规范"><a href="#服务端口规范" class="headerlink" title="服务端口规范"></a>服务端口规范</h3><ul><li>每个业务模块定义一个模块ID，如账户模块：20</li><li>Web模块：<ul><li>Server Port：模块ID+80，如2080</li><li>Manager Port：模块ID+81，如2181</li></ul></li><li>Server模块：<ul><li>Server Port：模块ID+09，如2009</li><li>Dubbo Port：模块ID+08，如2008</li></ul></li><li>MySQL：模块ID+06，如2006</li></ul><h3 id="方法命名规范"><a href="#方法命名规范" class="headerlink" title="方法命名规范"></a>方法命名规范</h3><p>总体上根据阿里巴巴编码规范进行约束。</p><ul><li>新增：save…</li><li>修改：update…</li><li>查询：find…，如findByName</li><li>查询所有：findAll</li><li>分页查询：find…ByPage</li><li>删除：delete</li><li>批量删除：batchDelete</li><li>业务方法：动词+名词组合</li><li>kafka主题：topic-业务名称</li><li>kafka消费组：group-模块名称</li></ul><h3 id="接口定义规范"><a href="#接口定义规范" class="headerlink" title="接口定义规范"></a>接口定义规范</h3><p>统一返回格式：</p><ul><li>BaseResult</li><li>GeneralReulst<t></t></li><li>ListResult</li></ul><p>其他：</p><ul><li>新增接口理应返回新增对象。</li><li>不允许把Json，Map这类对象传到Service中去，也不允许Service返回Json，Map这类对象。</li><li>Controller尽量少打日志，Controller里的日志通过AOP去打，除非第三方接口回调。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;代码拥有统一的格式和规范，既便于代码的逻辑清晰，又便于维护，好的编码规范可以尽可能的减少一个软件的维护成本。下面从三个方面进行约束：服务端口规范，方法命名规范，接口定义规范。&lt;/p&gt;
    
    </summary>
    
    
      <category term="代码规范" scheme="http://www.idlforever.cn/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>Servlet3.0规范</title>
    <link href="http://www.idlforever.cn/2018/01/29/Servlet3-0%E8%A7%84%E8%8C%83/"/>
    <id>http://www.idlforever.cn/2018/01/29/Servlet3-0规范/</id>
    <published>2018-01-29T18:52:44.000Z</published>
    <updated>2018-04-14T09:24:29.525Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1.什么是Servlet?</strong></p><p><code>Servlet</code>是一个基于Java技术的Web组件，生成动态的内容，并通过容器管理。</p><p><strong>2.什么是Servlet容器？</strong></p><p><strong>Servlet容器</strong>是Web服务或应用服务的一部分，它提供了发送请求，响应，解码基于MIME的请求，格式化基于mime的响应。并且管理Servlet的声明周期。</p><a id="more"></a><h3 id="Servlet-API"><a href="#Servlet-API" class="headerlink" title="Servlet API"></a>Servlet API</h3><p><strong>Servlet</strong>接口是Java Servlet API的核心抽象。所有Servlet接口必须直接实现或者继承实现了该接口的类。Java Servlet API提供了两个实现该接口的类。<strong>GenericServlet</strong>和<strong>HttpServlet</strong>。大多数场合，开发者都会继承<strong>HttpServlet</strong>来实现Servlet接口。</p><h3 id="处理请求的方法"><a href="#处理请求的方法" class="headerlink" title="处理请求的方法"></a>处理请求的方法</h3><p>基础的Servlet提供了一个<strong>service</strong>方法来处理客户端请求。每个请求都会被Servlet容器<strong>路由</strong>到对应的Servlet实例上调用其service方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;1.什么是Servlet?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Servlet&lt;/code&gt;是一个基于Java技术的Web组件，生成动态的内容，并通过容器管理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.什么是Servlet容器？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Servlet容器&lt;/strong&gt;是Web服务或应用服务的一部分，它提供了发送请求，响应，解码基于MIME的请求，格式化基于mime的响应。并且管理Servlet的声明周期。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>git无密码push</title>
    <link href="http://www.idlforever.cn/2018/01/15/git%E6%97%A0%E5%AF%86%E7%A0%81push/"/>
    <id>http://www.idlforever.cn/2018/01/15/git无密码push/</id>
    <published>2018-01-15T10:39:10.000Z</published>
    <updated>2018-04-14T09:24:29.525Z</updated>
    
    <content type="html"><![CDATA[<h1 id="git-ssh-免密提交"><a href="#git-ssh-免密提交" class="headerlink" title="git ssh 免密提交"></a>git ssh 免密提交</h1><ol><li>查看配置</li></ol><blockquote><p>git config –lis<br>用户名和邮箱如果填写过则pass<br>git config –global user.name “username”<br>git config –global user.email  “<a href="mailto:mail@qq.com" target="_blank" rel="noopener">mail@qq.com</a>“</p></blockquote><ol><li>生成SSH秘钥(group-hms-key是别名，随意取)</li></ol><blockquote><p>ssh-keygen -t rsa -C “group-hms-key”</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">执行后，</span><br><span class="line">第一个提示输入保存文件名，默认为空，回车。</span><br><span class="line">第二个提示输入密钥，默认为空，回车</span><br><span class="line">第三个确认刚输入密钥，默认为空，回车</span><br><span class="line">完成后，默认保存位置当前   用户名下/.ssh/id_rsa 和id_rsa.pub（windows8和10下位置是：C:\Users\用户名）</span><br></pre></td></tr></table></figure><ol><li>设置密钥</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">上面创建的git server的用户，这里创建的Gitblit内部用于管理权限的用户，两者要同名，当通过https链接git服务器时，需要输入用户名和密码，密码就是GitBlit中创建用户时填写的密码。</span><br><span class="line"></span><br><span class="line">创建好以后，用新账号登陆（不是admin账号），然后在当前用户的用户中心把 id_rsa.pub 中的内容复制到SSH Keys，保存确定。</span><br></pre></td></tr></table></figure><ol><li>clone 克隆设置</li></ol><blockquote><ul><li>ssh://test@ip:port/test.git  *<br>注意：<strong>ssh请求才能无密码访问，ssh key对https请求无效</strong>。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;git-ssh-免密提交&quot;&gt;&lt;a href=&quot;#git-ssh-免密提交&quot; class=&quot;headerlink&quot; title=&quot;git ssh 免密提交&quot;&gt;&lt;/a&gt;git ssh 免密提交&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;查看配置&lt;/li&gt;
&lt;/ol&gt;
&lt;blockqu
      
    
    </summary>
    
    
      <category term="团队协作" scheme="http://www.idlforever.cn/tags/%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>修改yum源</title>
    <link href="http://www.idlforever.cn/2018/01/08/%E4%BF%AE%E6%94%B9yum%E6%BA%90/"/>
    <id>http://www.idlforever.cn/2018/01/08/修改yum源/</id>
    <published>2018-01-08T14:00:53.000Z</published>
    <updated>2018-04-14T09:24:29.525Z</updated>
    
    <content type="html"><![CDATA[<h1 id="修改yum源"><a href="#修改yum源" class="headerlink" title="修改yum源"></a>修改yum源</h1><h2 id="1-备份系统自带yum源文件-etc-yum-repos-d-CentOS-Base-repo"><a href="#1-备份系统自带yum源文件-etc-yum-repos-d-CentOS-Base-repo" class="headerlink" title="1. 备份系统自带yum源文件:/etc/yum.repos.d/CentOS-Base.repo"></a>1. 备份系统自带yum源文件:/etc/yum.repos.d/CentOS-Base.repo</h2><blockquote><p>cd /etc/yum.repos.d/<br>cp CentOS-Base.repo CentOS-Base.repo_bak</p></blockquote><h2 id="2-下载ailiyun-163的yum源配置文件到-etc-yum-repos-d"><a href="#2-下载ailiyun-163的yum源配置文件到-etc-yum-repos-d" class="headerlink" title="2. 下载ailiyun/163的yum源配置文件到/etc/yum.repos.d/"></a>2. 下载ailiyun/163的yum源配置文件到/etc/yum.repos.d/</h2><blockquote><p>wget -O /etc/yum.repos.d/CentOS-Base.repo<br><a href="http://mirrors.aliyun.com/repo/Centos-7.repo" target="_blank" rel="noopener">http://mirrors.aliyun.com/repo/Centos-7.repo</a></p></blockquote><h2 id="3-刷缓存yum-makecache并更新"><a href="#3-刷缓存yum-makecache并更新" class="headerlink" title="3. 刷缓存yum makecache并更新"></a>3. 刷缓存yum makecache并更新</h2><blockquote><p>yum -y update</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;修改yum源&quot;&gt;&lt;a href=&quot;#修改yum源&quot; class=&quot;headerlink&quot; title=&quot;修改yum源&quot;&gt;&lt;/a&gt;修改yum源&lt;/h1&gt;&lt;h2 id=&quot;1-备份系统自带yum源文件-etc-yum-repos-d-CentOS-Base-repo&quot;&gt;
      
    
    </summary>
    
    
      <category term="linux" scheme="http://www.idlforever.cn/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Git的常用命令</title>
    <link href="http://www.idlforever.cn/2017/12/25/Git%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://www.idlforever.cn/2017/12/25/Git的常用命令/</id>
    <published>2017-12-25T15:40:03.000Z</published>
    <updated>2018-04-14T09:24:29.525Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git的常用命令"><a href="#Git的常用命令" class="headerlink" title="Git的常用命令"></a>Git的常用命令</h1><h2 id="利用Github创建远程仓库"><a href="#利用Github创建远程仓库" class="headerlink" title="利用Github创建远程仓库"></a>利用Github创建远程仓库</h2><h3 id="1-在Github上创建一个仓库"><a href="#1-在Github上创建一个仓库" class="headerlink" title="1. 在Github上创建一个仓库"></a>1. 在Github上创建一个仓库</h3><h3 id="2-在本地创建项目，并创建readme-md和-gitignore"><a href="#2-在本地创建项目，并创建readme-md和-gitignore" class="headerlink" title="2. 在本地创建项目，并创建readme.md和.gitignore"></a>2. 在本地创建项目，并创建readme.md和.gitignore</h3><blockquote><p>touch README.md<br>touch .gitignore</p></blockquote><p>.gitignore文件内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">*.class</span><br><span class="line"></span><br><span class="line">#package file</span><br><span class="line">*.war</span><br><span class="line">*.ear</span><br><span class="line"></span><br><span class="line">#kdiff3 ignore</span><br><span class="line">*.orig</span><br><span class="line"></span><br><span class="line">#maven ignore</span><br><span class="line">target/</span><br><span class="line"></span><br><span class="line">#eclipse</span><br><span class="line">.settings/</span><br><span class="line">.project</span><br><span class="line">.classpath</span><br><span class="line"></span><br><span class="line">#idea</span><br><span class="line">.idea/</span><br><span class="line">/idea/</span><br><span class="line">*.ipr</span><br><span class="line">*.iml</span><br><span class="line">*.iws</span><br><span class="line"></span><br><span class="line">#temp file</span><br><span class="line">*.log</span><br><span class="line">*.cache</span><br><span class="line">*.diff</span><br><span class="line">*.path</span><br><span class="line">*.tmp</span><br><span class="line"></span><br><span class="line">#system</span><br><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br></pre></td></tr></table></figure><h3 id="3-执行如下命令："><a href="#3-执行如下命令：" class="headerlink" title="3. 执行如下命令："></a>3. 执行如下命令：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git init  <span class="comment">// 初始化本地仓库</span></span><br><span class="line">git add .  <span class="comment">// 将工作区的变化提交到暂存区(index)</span></span><br><span class="line">git commit -am <span class="string">'first commit'</span>  <span class="comment">// 提交到head</span></span><br><span class="line">git remote add <span class="string">"https://github.com/youproject.git"</span>  <span class="comment">// 添加更改到远程仓库</span></span><br><span class="line">git push -u -f origin master <span class="comment">// 第一次提交要加上'-f'参数强制提交</span></span><br><span class="line">git checkout -b dev <span class="comment">// 创建dev 分支</span></span><br><span class="line">git push origin HEAD -u <span class="comment">// 提交分支到远程仓库</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Git的常用命令&quot;&gt;&lt;a href=&quot;#Git的常用命令&quot; class=&quot;headerlink&quot; title=&quot;Git的常用命令&quot;&gt;&lt;/a&gt;Git的常用命令&lt;/h1&gt;&lt;h2 id=&quot;利用Github创建远程仓库&quot;&gt;&lt;a href=&quot;#利用Github创建远程仓库&quot;
      
    
    </summary>
    
    
      <category term="团队协作" scheme="http://www.idlforever.cn/tags/%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>Java中元算符的优先级</title>
    <link href="http://www.idlforever.cn/2017/12/21/Java%E4%B8%AD%E5%85%83%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7/"/>
    <id>http://www.idlforever.cn/2017/12/21/Java中元算符的优先级/</id>
    <published>2017-12-21T14:20:31.000Z</published>
    <updated>2018-04-14T09:24:29.525Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java中运算符优先级"><a href="#Java中运算符优先级" class="headerlink" title="Java中运算符优先级"></a>Java中运算符优先级</h1><h3 id="1-问题引出"><a href="#1-问题引出" class="headerlink" title="1. 问题引出"></a>1. 问题引出</h3><p>今天在写ArrayList的扩容时，遇到这么一个错误:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line"><span class="keyword">int</span> newCapacity = oldCapacity + oldCapacity &gt;&gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>结果在执行的时候报了ArrayIndexOutOfBoundsException数组下标异常，通过debug发现newCapacity的值还是原来的值，发现是优先级导致的问题。<strong>加减乘除</strong>的优先级是高于<strong>位移</strong>运算符的。就此来回顾下Java中运算符优先级的问题。</p><h3 id="2-关于Java中的优先级"><a href="#2-关于Java中的优先级" class="headerlink" title="2. 关于Java中的优先级"></a>2. 关于Java中的优先级</h3><table><thead><tr><th style="text-align:center">优先级</th><th style="text-align:center">运算符</th><th style="text-align:center">结合性</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">()[]</td><td style="text-align:center">从左到右</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">! + (正) -(负) ~ ++ –</td><td style="text-align:center">从右向左</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">* / %</td><td style="text-align:center">从左向右</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">+(加) -(减)</td><td style="text-align:center">从左向右</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">&lt;&lt; &gt;&gt; &gt;&gt;&gt;</td><td style="text-align:center">从左向右</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">&lt; &lt;= &gt; &gt;= instanceof</td><td style="text-align:center">从左向右</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">== !=</td><td style="text-align:center">从左向右</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">&amp;(按位与)</td><td style="text-align:center">从左向右</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">^</td><td style="text-align:center">从左向右</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">\</td><td style="text-align:center"></td><td>从左向右</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">&amp;&amp;</td><td style="text-align:center">从左向右</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">\</td><td style="text-align:center">\</td><td></td><td>从左向右</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">?</td><td style="text-align:center">从右向左</td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">= += -+ *= /=</td><td style="text-align:center">从右向左</td></tr></tbody></table><p>口诀：</p><blockquote><p>单目乘除为关系，逻辑三目后赋值。</p></blockquote><p>单目：单目运算符+ –(负数) ++ – 等<br>乘除：算数单目运算符* / % + -<br>为：位移单目运算符&lt;&lt; &gt;&gt;<br>关系：关系单目运算符&gt; &lt; &gt;= &lt;= == !=<br>逻辑：逻辑单目运算符&amp;&amp; || &amp; | ^<br>三目：三目单目运算符A &gt; B ? X : Y<br>后：无意义，仅仅为了凑字数<br>赋值：赋值=</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java中运算符优先级&quot;&gt;&lt;a href=&quot;#Java中运算符优先级&quot; class=&quot;headerlink&quot; title=&quot;Java中运算符优先级&quot;&gt;&lt;/a&gt;Java中运算符优先级&lt;/h1&gt;&lt;h3 id=&quot;1-问题引出&quot;&gt;&lt;a href=&quot;#1-问题引出&quot; cla
      
    
    </summary>
    
    
      <category term="Java" scheme="http://www.idlforever.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList中的elementData为什么用transient</title>
    <link href="http://www.idlforever.cn/2017/12/20/ArrayList%E4%B8%AD%E7%9A%84elementData%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8transient/"/>
    <id>http://www.idlforever.cn/2017/12/20/ArrayList中的elementData为什么用transient/</id>
    <published>2017-12-20T10:05:53.000Z</published>
    <updated>2018-04-14T09:24:29.525Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ArrayList中elementData数组为什么是transient"><a href="#ArrayList中elementData数组为什么是transient" class="headerlink" title="ArrayList中elementData数组为什么是transient"></a>ArrayList中elementData数组为什么是transient</h1><h2 id="java中的transient关键字"><a href="#java中的transient关键字" class="headerlink" title="java中的transient关键字"></a>java中的transient关键字</h2><p>Java中serialization提供了一种持久化实例对象的机制。有可能有个对象的成员我们不想用serialization机制来保存它。就可以在这个成员变量上加上关键字transient。<br><strong>transient</strong>是Java中的关键字，用来表示一个域不是该对象串行化的一部分。</p><h2 id="ArrayList中elementData用transient的原因"><a href="#ArrayList中elementData用transient的原因" class="headerlink" title="ArrayList中elementData用transient的原因"></a>ArrayList中elementData用<strong>transient</strong>的原因</h2><p>elementData数组是实现ArrayList的关键数据结构。但数组中的元素往往大于我们真实存储的数据，当容量不够时会继续扩容。如果将elementData串行化，会导致空间的浪费。所以ArrayList的设计者将elementData设计为transient,然后再<strong>writeObject</strong>方法中手动进行序列化，只序列互实际存储的那些元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Save the state of the &lt;tt&gt;ArrayList&lt;/tt&gt; instance to a stream (that</span></span><br><span class="line"><span class="comment">  * is, serialize it).</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@serialData</span> The length of the array backing the &lt;tt&gt;ArrayList&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">  *             instance is emitted (int), followed by all of its elements</span></span><br><span class="line"><span class="comment">  *             (each an &lt;tt&gt;Object&lt;/tt&gt;) in the proper order.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">     <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">     <span class="comment">// Write out element count, and any hidden stuff</span></span><br><span class="line">     <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">     s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Write out size as capacity for behavioural compatibility with clone()</span></span><br><span class="line">     s.writeInt(size);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">         s.writeObject(elementData[i]);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ArrayList中elementData数组为什么是transient&quot;&gt;&lt;a href=&quot;#ArrayList中elementData数组为什么是transient&quot; class=&quot;headerlink&quot; title=&quot;ArrayList中elementDat
      
    
    </summary>
    
    
      <category term="Java源码" scheme="http://www.idlforever.cn/tags/Java%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>学习flowable</title>
    <link href="http://www.idlforever.cn/2017/12/14/%E5%AD%A6%E4%B9%A0flowable/"/>
    <id>http://www.idlforever.cn/2017/12/14/学习flowable/</id>
    <published>2017-12-14T20:47:33.000Z</published>
    <updated>2018-04-14T09:24:29.525Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl --user kermit:kermit -F &quot;file=D:\Workspaces\IntelliJ\study\flowable\src\main\resources\holiday-request.bpmn20.xml&quot; http://localhost:8080/flowable-rest/service/reposity/deployments</span><br><span class="line"></span><br><span class="line">curl --user kermit:kermit http://localhost:8080/flowable-rest/service/reposity/process-definitions</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
      <category term="java工作流" scheme="http://www.idlforever.cn/tags/java%E5%B7%A5%E4%BD%9C%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>idea安装配置</title>
    <link href="http://www.idlforever.cn/2017/12/07/idea%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    <id>http://www.idlforever.cn/2017/12/07/idea安装配置/</id>
    <published>2017-12-07T13:40:22.000Z</published>
    <updated>2018-04-14T09:24:29.525Z</updated>
    
    <content type="html"><![CDATA[<h1 id="intellij-idea-2017-3安装配置"><a href="#intellij-idea-2017-3安装配置" class="headerlink" title="intellij idea 2017.3安装配置"></a>intellij idea 2017.3安装配置</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>从官网下载旗舰版安装文件,一路next，安装成功。</p><h2 id="破解"><a href="#破解" class="headerlink" title="破解"></a>破解</h2><p> license server下输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://idea.iteblog.com/key.php</span><br></pre></td></tr></table></figure></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>点击Configuration—&gt;defaultSettings。<br><strong>配置maven</strong><br><img src="http://upload.ouliu.net/i/20171207135218vb9aa.png" alt="maven配置"></p><h2 id="tomcat内存不足配置"><a href="#tomcat内存不足配置" class="headerlink" title="tomcat内存不足配置"></a>tomcat内存不足配置</h2><p>在Run/Debug configuration 的你要运行行的tomcat里面的<br>vm options里面输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-server -XX:PermSize=128M -XX:MaxPermSize=256m</span><br><span class="line">或</span><br><span class="line">-server -XX:PermSize=521M -XX:MaxPermSize=1024m</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;intellij-idea-2017-3安装配置&quot;&gt;&lt;a href=&quot;#intellij-idea-2017-3安装配置&quot; class=&quot;headerlink&quot; title=&quot;intellij idea 2017.3安装配置&quot;&gt;&lt;/a&gt;intellij idea 
      
    
    </summary>
    
    
      <category term="开发工具" scheme="http://www.idlforever.cn/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>maven导入本地jar导致NoClassDefFoundError</title>
    <link href="http://www.idlforever.cn/2017/11/30/maven%E5%AF%BC%E5%85%A5%E6%9C%AC%E5%9C%B0jar%E5%AF%BC%E8%87%B4NoClassDefFoundError/"/>
    <id>http://www.idlforever.cn/2017/11/30/maven导入本地jar导致NoClassDefFoundError/</id>
    <published>2017-11-30T19:42:20.000Z</published>
    <updated>2018-04-14T09:24:29.525Z</updated>
    
    <content type="html"><![CDATA[<h1 id="maven导入本地jar导致NoClassDefFoundError"><a href="#maven导入本地jar导致NoClassDefFoundError" class="headerlink" title="maven导入本地jar导致NoClassDefFoundError"></a>maven导入本地jar导致NoClassDefFoundError</h1><p><strong>方法一</strong><br>将jar包打包到本地仓库<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mvn install:install-file -Dfile=D:/internetenv/myLib/alipay/alipay-trade-sdk.jar -DgroupId=com.alibaba -DartifactId=aliPayDemo -Dversion=<span class="number">2.0</span> -Dpackaging=jar</span><br><span class="line"></span><br><span class="line">mvn install:install-file -Dfile=D:/internetenv/myLib/alipay/alipay-sdk-java20160302220055.jar -DgroupId=com.alibaba -DartifactId=aliPay -Dversion=<span class="number">2.0</span> -Dpackaging=jar</span><br><span class="line"></span><br><span class="line">mvn install:install-file -Dfile=D:/internetenv/system/lib/wxpay-scanpay-java-sdk-<span class="number">1.0</span>.jar -DgroupId=com.tencent -DartifactId=wxpay-scanpay-java-sdk -Dversion=<span class="number">1.0</span> -Dpackaging=jar</span><br></pre></td></tr></table></figure></p><p><strong>方法二</strong><br>配置Maven插件</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;executions&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">            &lt;id&gt;copy-dependencies&lt;/id&gt;</span><br><span class="line">            &lt;phase&gt;compile&lt;/phase&gt;</span><br><span class="line">            &lt;goals&gt;</span><br><span class="line">                &lt;goal&gt;copy-dependencies&lt;/goal&gt;</span><br><span class="line">            &lt;/goals&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;outputDirectory&gt;$&#123;project.build.directory&#125;/$&#123;project.build.finalName&#125;/WEB-INF/lib&lt;/outputDirectory&gt;</span><br><span class="line">                &lt;includeScope&gt;system&lt;/includeScope&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">        &lt;/execution&gt;</span><br><span class="line">    &lt;/executions&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;maven导入本地jar导致NoClassDefFoundError&quot;&gt;&lt;a href=&quot;#maven导入本地jar导致NoClassDefFoundError&quot; class=&quot;headerlink&quot; title=&quot;maven导入本地jar导致NoClassDef
      
    
    </summary>
    
    
      <category term="Java异常" scheme="http://www.idlforever.cn/tags/Java%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>理解JavaScript中的闭包</title>
    <link href="http://www.idlforever.cn/2017/11/27/%E7%90%86%E8%A7%A3JavaScript%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85/"/>
    <id>http://www.idlforever.cn/2017/11/27/理解JavaScript中的闭包/</id>
    <published>2017-11-27T17:48:54.000Z</published>
    <updated>2018-04-14T09:24:29.525Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入理解JavaScript中的闭包"><a href="#深入理解JavaScript中的闭包" class="headerlink" title="深入理解JavaScript中的闭包"></a>深入理解JavaScript中的闭包</h1><h2 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h2><p><strong>闭包</strong>是词法作用域的体现。简单的说，一个持有外部环境变量的函数就是闭包。闭包的本质是词法作用域和函数当作值传递。</p><p><strong>词法作用域</strong>是只作用域在代码书写或定义的时候就确定的，而动态作用域是在代码执行的时候确定的。词法作用域关注的是<strong>何处声明</strong>，动态作用域关注的是<strong>何处调用</strong>。</p><p>看下面代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   print a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">bar();</span><br></pre></td></tr></table></figure></p><p>上述代码词法作用域语言中输出的是2，比如Js中，在动态作用域语言中输出的是3。</p><p>我们再来看看闭包的代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> local = <span class="number">2</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> local;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> inner;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fn = outer();</span><br><span class="line"><span class="built_in">console</span>.log(fn());</span><br></pre></td></tr></table></figure></p><p>上面的例子中外部函数outer中定义了内部函数inner，然后将inner函数对象作为值返回。之后执行了outer()函数，在js中outer函数的作用域会被销毁，因为引擎会有垃圾回收器来释放不在使用的内存。<br>因为这里将函数作为返回值了，产生了闭包，因为闭包的存在，我们依然能够访问到local变量，所有outer的词法作用域依然存在。因此也就证明了，<strong>闭包可访问所在的词法作用域并且拥有更长的生命周期，保持对当前词法作用域的引用。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;深入理解JavaScript中的闭包&quot;&gt;&lt;a href=&quot;#深入理解JavaScript中的闭包&quot; class=&quot;headerlink&quot; title=&quot;深入理解JavaScript中的闭包&quot;&gt;&lt;/a&gt;深入理解JavaScript中的闭包&lt;/h1&gt;&lt;h2 id=&quot;什
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://www.idlforever.cn/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>了解lambda表达式</title>
    <link href="http://www.idlforever.cn/2017/11/23/%E4%BA%86%E8%A7%A3lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://www.idlforever.cn/2017/11/23/了解lambda表达式/</id>
    <published>2017-11-23T14:30:36.000Z</published>
    <updated>2018-04-14T09:24:29.525Z</updated>
    
    <content type="html"><![CDATA[<h1 id="了解lambda表达式"><a href="#了解lambda表达式" class="headerlink" title="了解lambda表达式"></a>了解lambda表达式</h1><h2 id="什么是lambda"><a href="#什么是lambda" class="headerlink" title="什么是lambda"></a>什么是lambda</h2><p>lambda表达式是一段可以传递的代码，它的核心思想是将面向对象中的传递数据变成传递行为。<br>我们回顾下jdk8之前编写线程时的代码段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"do something."</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把<strong>Runnable</strong>对象传给<strong>Thread</strong>对象作为构造参数时创建一个线程，运行后将输出do something.。<br>我们使用匿名内部类的方式实现了该方法。设计匿名内部类的目的，就是为了方便Java程序员将代码作为数据传递。不多匿名内部类还是不够简便。为了实现一个简单的逻辑，不得不加上6行冗繁的样板代码。如果是lambda会怎么做？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runnable r = () -&gt; System.out.println(<span class="string">"do something."</span>);</span><br></pre></td></tr></table></figure><p>这样的代码很酷，使用<strong>-&gt;</strong>将参数和实现逻辑分离，当运行这个线程的时候执行的是<strong>-&gt;</strong>之后的代码段，而且编译器帮助我们做了类型推倒；<br>下面我们一起来学习lambda的语法。</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>在lambda中我们遵循如下的表达式来编写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expression = (variable) -&gt; action</span><br></pre></td></tr></table></figure><ul><li><strong>variable</strong>：这是一个变量，一个占位符。像x，y，z可以是多个变量。</li><li><strong>action</strong>：这里我们称之为action，这是我们实现代码逻辑的部分。当一个动作实现无法用一行代码完成，可以用<strong>{}</strong>包裹起来。</li></ul><p>lambda表达式可以包含多个参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = (x, y) -&gt; x + y;</span><br></pre></td></tr></table></figure><p>这个时候我们思考这段代码不是之前的x和y数字相加，而是创建了一个函数，用来计算两个数的和。<br>后面用int类型进行接收。在lambda表达式中我们省略了return。</p><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>函数式接口是只有一个方法的接口，用作lambda表达式的类型。来看看jdk中的<strong>Runnable</strong>源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="尝试函数式接口"><a href="#尝试函数式接口" class="headerlink" title="尝试函数式接口"></a>尝试函数式接口</h3><p>我们来编写一个函数式接口，输入一个年龄，判断这个人是否是成年人。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionalInterfaceDemo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@FunctionalInterface</span></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">doPredicate</span><span class="params">(<span class="keyword">int</span> age, Predicate&lt;Integer&gt; predicate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> predicate.test(age);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isAdult = doPredicate(<span class="number">20</span>, x -&gt; x &gt;= <span class="number">18</span>);</span><br><span class="line">        System.out.println(isAdult);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个列子我们很轻松的完成是否是承认的动作，在此之前我们的做法是编写一个判断是否是成人的方法，是无法将判断公用的。而在本例中你只需要将<strong>行为</strong>传递进去。</p><p>jdk中为我们提供了<strong>java.util.function</strong>包<br><img src="http://i1.bvimg.com/619704/6ea5c79f6aa4a444t.jpg" alt="Markdown"></p><p>我们前面写的Predicate接口函数也是jdk中的一个实现，他们大致分为以下几类：</p><table><thead><tr><th style="text-align:center">接口</th><th style="text-align:center">类型</th><th style="text-align:center">参数</th><th style="text-align:center">返回值</th><th style="text-align:center">事例</th></tr></thead><tbody><tr><td style="text-align:center">consumer</td><td style="text-align:center">消费型接口</td><td style="text-align:center">T</td><td style="text-align:center">void</td><td style="text-align:center">输出一个值</td></tr><tr><td style="text-align:center">supplier</td><td style="text-align:center">供给型接口</td><td style="text-align:center">None</td><td style="text-align:center">T</td><td style="text-align:center">工厂方法</td></tr><tr><td style="text-align:center">function</td><td style="text-align:center">函数型接口</td><td style="text-align:center">T</td><td style="text-align:center">R</td><td style="text-align:center">获得Animal对象的名字</td></tr><tr><td style="text-align:center">predicate</td><td style="text-align:center">断言型接口</td><td style="text-align:center">T</td><td style="text-align:center">boolean</td><td style="text-align:center">这个用户已经成年了吗</td></tr></tbody></table><p><strong>消费型接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">donation</span><span class="params">(Integer money, Consumer&lt;Integer&gt; consumer)</span> </span>&#123;</span><br><span class="line">    consumer.accept(money);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    donation(<span class="number">1000</span>, money -&gt; System.out.println(<span class="string">"捐赠了"</span> + money + <span class="string">"元"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>供给型接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">supply</span><span class="params">(Integer num, Supplier&lt;Integer&gt; supplier)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; resultList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">        resultList.add(supplier.get());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultList;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = supply(<span class="number">10</span>, () -&gt; (<span class="keyword">int</span>)(Math.random() * <span class="number">100</span>));</span><br><span class="line">    list.forEach(item -&gt; System.out.println(item));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>函数型接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">convert</span><span class="params">(String str, Function&lt;String, Integer&gt; function)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> function.apply(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer value = convert(<span class="string">"28"</span>, str -&gt; Integer.parseInt(str));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>断言型接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">filter</span><span class="params">(List&lt;String&gt; fruit, Predicate&lt;String&gt; predicate)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; f = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String s : fruit) &#123;</span><br><span class="line">        <span class="keyword">if</span>(predicate.test(s)) &#123;</span><br><span class="line">            f.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; fruit = Arrays.asList(<span class="string">"香蕉"</span>, <span class="string">"哈密瓜"</span>, <span class="string">"火龙果"</span>);</span><br><span class="line">    List&lt;String&gt; newFruit = filter(fruit, (f) -&gt; f.length() == <span class="number">2</span>);</span><br><span class="line">    System.out.println(newFruit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;了解lambda表达式&quot;&gt;&lt;a href=&quot;#了解lambda表达式&quot; class=&quot;headerlink&quot; title=&quot;了解lambda表达式&quot;&gt;&lt;/a&gt;了解lambda表达式&lt;/h1&gt;&lt;h2 id=&quot;什么是lambda&quot;&gt;&lt;a href=&quot;#什么是lambd
      
    
    </summary>
    
    
      <category term="Java8" scheme="http://www.idlforever.cn/tags/Java8/"/>
    
  </entry>
  
  <entry>
    <title>单一职责原则</title>
    <link href="http://www.idlforever.cn/2017/11/22/%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/"/>
    <id>http://www.idlforever.cn/2017/11/22/单一职责原则/</id>
    <published>2017-11-22T19:03:31.000Z</published>
    <updated>2018-04-14T09:24:29.525Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>不要存在多于一个导致类变更的原因。**通俗的说，即一个类只负责一项职责。</p><h2 id="问题由来"><a href="#问题由来" class="headerlink" title="问题由来"></a>问题由来</h2><p>类T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责P2功能发生故障。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>遵循单一职责原则。分别建立两个类T1、T2，使T1完成职责P1功能，T2完成职责P2功能。这样，当修改类T1时，不会使职责P2发生故障风险；同理，当修改T2时，也不会使职责P1发生故障风险。</p><p>说到单一职责原则，很多人都会不屑一顾。因为它太简单了。稍有经验的程序员即使从来没有读过设计模式、从来没有听说过单一职责原则，在设计软件时也会自觉的遵守这一重要原则，因为这是常识。在软件编程中，谁也不希望因为修改了一个功能导致其他的功能发生故障。而避免出现这一问题的方法便是遵循单一职责原则。虽然单一职责原则如此简单，并且被认为是常识，但是即便是经验丰富的程序员写出的程序，也会有违背这一原则的代码存在。为什么会出现这种现象呢？因为有职责扩散。<strong>所谓职责扩散，就是因为某种原因，职责P被分化为粒度更细的职责P1和P2</strong>。</p><p>比如：类T只负责一个职责P，这样设计是符合单一职责原则的。后来由于某种原因，也许是需求变更了，也许是程序的设计者境界提高了，需要将职责P细分为粒度更细的职责P1，P2，这时如果要使程序遵循单一职责原则，需要将类T也分解为两个类T1和T2，分别负责P1、P2两个职责。但是在程序已经写好的情况下，这样做简直太费时间了。所以，简单的修改类T，用它来负责两个职责是一个比较不错的选择，虽然这样做有悖于单一职责原则。（这样做的风险在于职责扩散的不确定性，因为我们不会想到这个职责P，在未来可能会扩散为P1，P2，P3，P4……Pn。所以记住，在职责扩散到我们无法控制的程度之前，立刻对代码进行重构。）</p><p>举例说明，用一个类描述动物呼吸这个场景：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breathe</span><span class="params">(String animal)</span></span>&#123;</span><br><span class="line">        System.out.println(animal+<span class="string">"呼吸空气"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Animal animal = <span class="keyword">new</span> Animal();</span><br><span class="line">        animal.breathe(<span class="string">"牛"</span>);</span><br><span class="line">        animal.breathe(<span class="string">"羊"</span>);</span><br><span class="line">        animal.breathe(<span class="string">"猪"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">牛呼吸空气  </span><br><span class="line">羊呼吸空气  </span><br><span class="line">猪呼吸空气  </span><br><span class="line">鱼呼吸水</span><br></pre></td></tr></table></figure><p>我们会发现如果这样修改花销是很大的，除了将原来的类分解之外，还需要修改客户端。而直接修改类Animal来达成目的虽然违背了单一职责原则，但花销却小的多，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breathe</span><span class="params">(String animal)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"鱼"</span>.equals(animal))&#123;</span><br><span class="line">            System.out.println(animal+<span class="string">"呼吸水"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(animal+<span class="string">"呼吸空气"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Animal animal = <span class="keyword">new</span> Animal();</span><br><span class="line">        animal.breathe(<span class="string">"牛"</span>);</span><br><span class="line">        animal.breathe(<span class="string">"羊"</span>);</span><br><span class="line">        animal.breathe(<span class="string">"猪"</span>);</span><br><span class="line">        animal.breathe(<span class="string">"鱼"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这种修改方式要简单的多。但是却存在着隐患：有一天需要将鱼分为呼吸淡水的鱼和呼吸海水的鱼，则又需要修改Animal类的breathe方法，而对原有代码的修改会对调用”猪””牛””羊”等相关功能带来风险，也许某一天你会发现程序运行的结果变为”牛呼吸水”了。这种修改方式直接在代码级别上违背了单一职责原则，虽然修改起来最简单，但隐患却是最大的。还有一种修改方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breathe</span><span class="params">(String animal)</span></span>&#123;</span><br><span class="line">        System.out.println(animal+<span class="string">"呼吸空气"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breathe2</span><span class="params">(String animal)</span></span>&#123;</span><br><span class="line">        System.out.println(animal+<span class="string">"呼吸水"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Animal animal = <span class="keyword">new</span> Animal();</span><br><span class="line">        animal.breathe(<span class="string">"牛"</span>);</span><br><span class="line">        animal.breathe(<span class="string">"羊"</span>);</span><br><span class="line">        animal.breathe(<span class="string">"猪"</span>);</span><br><span class="line">        animal.breathe2(<span class="string">"鱼"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这种修改方式没有改动原来的方法，而是在类中新加了一个方法，这样虽然也违背了单一职责原则，但在方法级别上却是符合单一职责原则的，因为它并没有动原来方法的代码。这三种方式各有优缺点，那么在实际编程中，采用哪一中呢？其实这真的比较难说，需要根据实际情况来确定。我的原则是：只有逻辑足够简单，才可以在代码级别上违反单一职责原则；只有类中方法数量足够少，才可以在方法级别上违反单一职责原则；</p><p>例如本文所举的这个例子，它太简单了，它只有一个方法，所以，无论是在代码级别上违反单一职责原则，还是在方法级别上违反，都不会造成太大的影响。实际应用中的类都要复杂的多，一旦发生职责扩散而需要修改类时，除非这个类本身非常简单，否则还是遵循单一职责原则的好。</p><p>遵循单一职责原的优点有：</p><ul><li>可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多；</li><li>提高类的可读性，提高系统的可维护性；</li><li>变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。</li></ul><p>需要说明的一点是单一职责原则不只是面向对象编程思想所特有的，只要是模块化的程序设计，都适用单一职责原则。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;单一职责原则&quot;&gt;&lt;a href=&quot;#单一职责原则&quot; class=&quot;headerlink&quot; title=&quot;单一职责原则&quot;&gt;&lt;/a&gt;单一职责原则&lt;/h1&gt;&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="设计模式" scheme="http://www.idlforever.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
